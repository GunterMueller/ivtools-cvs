This patch should improve raster support for the idraw output format
of pstoedit. Now you enter "drawtool -" directly into the print dialog
box of Netscape and have the PostScript rendered directly into the
drawing editor. Should work on pstoedit-3.30 and earlier releases, and
has been incorporated into pstoedit-3.31.

THIS PATCH HAD INCORRECT CONTENTS AS POSTED FROM SEP 2001 to JAN 2002.
(at least I mailed the right one to Wolfgang Glunz)


*** drvidraw.cpp.dist	Fri Sep  7 11:51:51 2001
--- src/drvidraw.cpp	Wed Sep 12 12:03:13 2001
***************
*** 35,41 ****
        iscale(X) != iscale(newpointlist[newtotalpoints-1]->x_) ||	\
        iscale(Y) != iscale(newpointlist[newtotalpoints-1]->y_)){		\
      newpointlist[newtotalpoints++] = new Point(X,Y);			\
!     assert(newpointlist[newtotalpoints] != NIL); }		        \
  } while (0)
  
  
--- 35,41 ----
        iscale(X) != iscale(newpointlist[newtotalpoints-1]->x_) ||	\
        iscale(Y) != iscale(newpointlist[newtotalpoints-1]->y_)){		\
      newpointlist[newtotalpoints++] = new Point(X,Y);			\
!     assert(newpointlist[newtotalpoints-1] != NIL); }		        \
  } while (0)
  
  
***************
*** 262,267 ****
--- 262,268 ----
  	outf << "/Circ {\n";
  	outf << "newpath\n";
  	outf << "0 360 arc\n";
+ 	outf << "closepath\n";
  	outf << "patternNone not { ifill } if\n";
  	outf << "brushNone not { istroke } if\n";
  	outf << "} def\n";
***************
*** 293,298 ****
--- 294,300 ----
  	outf << "translate\n";
  	outf << "scale\n";
  	outf << "0 0 1 0 360 arc\n";
+ 	outf << "closepath\n";
  	outf << "patternNone not { ifill } if\n";
  	outf << "brushNone not { istroke } if\n";
  	outf << "end\n";
***************
*** 842,848 ****
  			numpoints = totalpoints == 1 ? 1 : totalpoints - 1;
  			print_header("Poly");	// Output a polygon
  			outf << "%I " << numpoints << endl;
! 			for (i = 0; i < totalpoints; i++) {
  				outf << iscale(pointlist[i]->x_) << ' ';
  				outf << iscale(pointlist[i]->y_) << endl;
  			}
--- 844,850 ----
  			numpoints = totalpoints == 1 ? 1 : totalpoints - 1;
  			print_header("Poly");	// Output a polygon
  			outf << "%I " << numpoints << endl;
! 			for (i = 0; i < numpoints; i++) {
  				outf << iscale(pointlist[i]->x_) << ' ';
  				outf << iscale(pointlist[i]->y_) << endl;
  			}
*** image.cpp.dist	Fri Sep  7 11:55:02 2001
--- src/image.cpp	Wed Sep 12 12:17:30 2001
***************
*** 425,491 ****
  	outi << "%I" << endl;
  	const int perline = width;
  
! 	switch (type) {
! 	case colorimage:
! 		outi << width << " " << height << " " << bits <<
! 			" Rast { currentfile " << perline << " string readhexstring pop }" << endl;
! 		outi << "image";
! 		{
! 			int first = true;
! 			for (unsigned int i = 0; i < nextfreedataitem; i += 3) {
! 				if (i % (perline * ncomp) == 0) {
! 					outi << endl;	// debug " " << i << endl;
! 					first = true;
! 				}
! 				if (first) {
! 					first = false;
! 					outi << "%I ";
! 				}
! 				outi << setw(2) << setfill('0') << hex << (int) data[i] << dec;
! 			}
! 		}
! 		outi << endl << "%I colorimage";
  		{
! 			int first = true;
! 			for (unsigned int i = 0; i < nextfreedataitem; i++) {
! 				if (i % (perline * ncomp) == 0) {
! 					outi << endl;	// debug " " << i << endl;
! 					first = true;
! 				}
! 				if (first) {
! 					first = false;
! 					outi << "%I ";
! 				}
! 				outi << setw(2) << setfill('0') << hex << (int) data[i] << dec;
! 			}
! 		}
! 		if (nextfreedataitem % (perline * ncomp) != 0) {
! 			for (unsigned int i = nextfreedataitem; i % (perline * ncomp) != 0; i++)
! 				outi << setw(2) << setfill('0') << hex << 0 << dec;
! 		}
! 		break;
! 	case imagemask:
! 		// just treat it as a normal image for the moment
! 	case normalimage:
! 		outi << "/str1 1 string def" << endl << endl;
! 		outi << "% display normal image" << endl;
! 		outi << width << " " << height << " " << bits << " % width, height, bits/component" << endl;
! 		outi << "% number of data " << nextfreedataitem << endl;
! 		outi << "[ 1 0 0 1 0 0 ] %image matrix" << endl;
! 		outi << "{currentfile str1 readhexstring pop} % decoding procedure" << endl;
! 		outi << "image" << endl;
  		{
! 			for (unsigned int i = 0; i < nextfreedataitem; i++) {
! 				if (i % (12 * 3) == 0)
! 					outi << endl;
! 				outi << setw(2) << setfill('0') << hex << (unsigned int)
! 					data[i] << dec;
  			}
! 		}
! 		break;
! 	default:
! 		break;
  	}
  
  	outi << endl << "End " << endl << endl;
  }
--- 425,527 ----
  	outi << "%I" << endl;
  	const int perline = width;
  
! 	outi << width << " " << height << " " << "8" <<
! 	  " Rast { currentfile " << perline << " string readhexstring pop }" << endl;
! 	outi << "image";
! 
! 	/* unpack 4 bit rgb data, skipping last nybble on odd-width images */
! 	unsigned char* udata = NULL;
!         unsigned char* dataptr = data;
! 	if (bits==4) 
!         {
! 	       udata = new unsigned char[nextfreedataitem*2];
! 	       dataptr = udata;
! 
! 	       unsigned int curnybble = 0;  /* 0=r,1=g,2=b */
! 	       unsigned int curcol = 0;
! 	       unsigned int currow = 0;
! 	       unsigned int udata_loc=0;
! 
! 	       for (unsigned int i = 0; i< nextfreedataitem; i++) 
!                {
!      
! 	       	       /* replicate most-significant nybble first */
! 	               udata[udata_loc++] = (data[i]&0xf0) | ((data[i]&0xf0)>>4);
! 		     
!                        curnybble++;
! 		       if (curnybble==3) 
!                        {
! 		               curnybble=0;
! 		               curcol++;
! 		       }
! 
!                        /* replicate least-significant nybble if not at end of odd-width row */
! 		       if (curcol != width || !(width%2)) 
!                        {
! 			      udata[udata_loc++] = (data[i]&0x0f) | ((data[i]&0x0f)<<4);
! 
! 			      curnybble++;
! 			      if (curnybble==3) 
!                               {
! 			             curnybble=0;
! 			             curcol++;
! 			      }
! 		       }
! 
! 		       /* skip nybble at end of odd-width row */
! 		       if (curcol == width) 
!                        {
! 			      currow++;
! 			      curcol=0;
! 		       }
! 			  
! 	        }
!         }
! 
!         /* output graylevel image for B&W printers */
! 	int cur=0;
! 	for (unsigned int row = 0; row < height; row++) 
! 	{
! 	        outi << endl << "%I ";
! 		for (unsigned int col = 0; col < width; col++)
  		{
! 		        unsigned int grayval;
! 			if (type==colorimage) 
!                                 grayval = (unsigned int)
! 			                (.299*dataptr[cur++] 
!                                         + .587*dataptr[cur++] 
!                                         + .114*dataptr[cur++]);
! 			else
! 			        grayval = dataptr[cur++];       
! 			outi << setw(2) << setfill('0') << hex << grayval << dec;
! 		}                
! 	}
! 
!         /* output color image for use of idraw */
! 	outi << endl << "%I colorimage";
! 	cur = 0;
! 	for (unsigned int row = 0; row < height; row++) 
! 	{
! 	        outi << endl << "%I ";
! 		for (unsigned int col = 0; col < width; col++)
  		{
! 		        if (type==colorimage) 
!                         {       
! 		                outi << setw(2) << setfill('0') << hex << (unsigned int) dataptr[cur++] << dec;
! 		                outi << setw(2) << setfill('0') << hex << (unsigned int) dataptr[cur++] << dec;
! 		                outi << setw(2) << setfill('0') << hex << (unsigned int) dataptr[cur++] << dec;
! 
! 			} 
!                         else
! 			{
! 		                outi << setw(2) << setfill('0') << hex << (unsigned int) dataptr[cur] << dec;
! 		                outi << setw(2) << setfill('0') << hex << (unsigned int) dataptr[cur] << dec;
! 		                outi << setw(2) << setfill('0') << hex << (unsigned int) dataptr[cur++] << dec;
  			}
! 		}                
  	}
  
  	outi << endl << "End " << endl << endl;
+ 
+ 	delete [] udata;
  }
