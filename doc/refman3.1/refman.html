<HEAD>
<TITLE> InterViews 3.1 Reference Manual </TITLE>
</HEAD>

<BODY BGCOLOR="White">
<A NAME="PAGE1"></A>
<CENTER>
</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Copyright (c) 1992<BR>
</CENTER>
<CENTER>
The Board of Trustees of the Leland Stanford Junior University<BR><BR><BR><BR><BR>
</CENTER>
Permission to copy this manual or any portion thereof as necessary for use of<BR>
this software is hereby granted provided this copyright notice and statement of<BR>
permission are included.<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=9>
<!-- /Times-Bold -->
<B>InterViews Reference Manual<BR>
&nbsp;&nbsp;Version 3.1<BR><BR>
&nbsp;&nbsp;</B></FONT>
<FONT SIZE=4>
<!-- /Times-Italic -->
<I>December 14, 1992<BR><BR>
&nbsp;&nbsp;</I></FONT>
<FONT SIZE=6>
<!-- /Times-Roman -->
Mark A. Linton<BR>
&nbsp;&nbsp;Paul R. Calder<BR>
&nbsp;&nbsp;John A. Interrante<BR>
&nbsp;&nbsp;Steven Tang<BR>
&nbsp;&nbsp;John M. Vlissides
<BR>
<A NAME="PAGE2"></A>
<CENTER>
</FONT>
<FONT SIZE=9>
<!-- /Times-Bold -->
<B>Release Notes<BR>
</CENTER>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
The InterViews 3.1 distribution contains a README file and a single<BR>
subdirectory, #ivº, that contains the source and documentation. InterViews can be<BR>
compiled with any C++ compiler that accepts the 2.0, 2.1, or 3.0 revisions of the<BR>
language, and can run on X11R4 or X11R5. You can specify your compiler and<BR>
other site definitions in the file #iv/src/config/InterViews/local.defº.<BR>
&nbsp;&nbsp;The README file describes how to build InterViews. Under #iv/srcº, the<BR>
directory #include'' contains include directories, #binº contains applications (each<BR>
in its own subdirectory), #libº contains libraries (each in its own subdirectory),<BR>
#configº contains configuration-specific
&nbsp;&nbsp; files, #manº contains PostScript or troff<BR>
for the manual, and #papersº contains PostScript for user tutorials.<BR>
&nbsp;&nbsp;The work at Stanford has been supported by Fujitsu America, Digital<BR>
Equipment Corporation, and NASA CASIS project under Contract NAGW 419,<BR>
and a grant from the Charles Lee Powell Foundation. Special thanks to Ira<BR>
Machefsky of Digital and Charles Brauer of Fujitsu America for their assistance.<BR>
We are also grateful to the ever-growing InterViews user community for its<BR>
encouragement and support.<BR>
&nbsp;&nbsp;Please address questions or comments about InterViews to<BR>
&nbsp;&nbsp;Mark Linton<BR>
&nbsp;&nbsp;linton@sgi.com
<BR>
<A NAME="PAGE3"></A>
<CENTER>
</FONT>
<FONT SIZE=9>
<!-- /Times-Bold -->
<B>Differences between 3.0 and 3.1<BR>
</CENTER>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
InterViews 3.1 contains several improvements over 3.0.1. WidgetKit is an<BR>
improved implementation of the Kit class that was in 3.0.1. DialogKit is a class<BR>
that provides a file chooser dialog using WidgetKit compoments. LayoutKit is a<BR>
class that provides convenient operations for creating layout objects such as boxes<BR>
and glue, replacing the many independent classes such as LRBox and VGlue<BR>
in 3.0.1. Chapter 9 of the reference manual describes WidgetKit, Chapter 10<BR>
describes DialogKit, and Chapter 11 describes LayoutKit.<BR>
&nbsp;&nbsp;Glyph and other subclasses of Resource are no longer derived as virtual base<BR>
classes. This change was made primarily for efficiency and convenience because<BR>
many C++ compilers do not generate particularly efficient code for virtual base<BR>
classes (especially in space), and some compilers have bugs in this area.<BR>
&nbsp;&nbsp;The Glyph protocol has been extended with an <!-- /Times-Italic -->
<I>undraw </I><!-- /Times-Roman -->
operation that notifies a<BR>
glyph that it no longer has an allocation on the canvas. This operation is primarily<BR>
for objects that cache information or perform computation when they are visible.<BR>
&nbsp;&nbsp;A new monoglyph subclass, called InputHandler, replaces the old Listener<BR>
class. InputHandler is much simpler to use than the previous combination of<BR>
Listener and PointerHandler, as well as providing limited support for focus<BR>
management.<BR>
&nbsp;&nbsp;The Window class now has a style object as one of its attributes. The style can<BR>
be set to defined attributes such as name and geometry, as well as a #visualº type<BR>
for the window. On systems that support overlay planes, the attribute #overlayº<BR>
can be used to request the window be allocated in the window planes.<BR>
&nbsp;&nbsp;InterViews 3.1 also includes a new faster implementation of the Style class and<BR>
a copy of the latest version of Sam Leffler's TIFF library (v3.0) for reading<BR>
images. The old 2.6 structured graphics library is no longer included, though it<BR>
probably would still work with this distribution.<BR>
&nbsp;&nbsp;The documentation has been reorganized to reflect some of the 3.1 changes, as<BR>
well as provide a structure for future releases. In addition to the reference manual,<BR>
a new collection of example programs is provided under iv/src/examples.<BR><BR><BR><BR><BR>
&nbsp;&nbsp;0-2
<BR>
<A NAME="PAGE4"></A>
</FONT>
<FONT SIZE=9>
<!-- /Times-Bold -->
<B>Chapter 1<BR>
Introduction<BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
InterViews is a software system for window-based applications. Like most user<BR>
environments, InterViews is <!-- /Times-Italic -->
<I>object-oriented </I><!-- /Times-Roman -->
in that components such as windows,<BR>
buttons, menus, and documents are active elements with inherited behavior. The<BR>
name #InterViewsº comes from the idea of a user interface object presenting<BR>
an <!-- /Times-Italic -->
<I>interactive view </I><!-- /Times-Roman -->
of some data. For example, a text editor implements an<BR>
interactive view of the contents of a text file.<BR>
&nbsp;&nbsp;InterViews provides a set of classes that define the behavior of user interface<BR>
objects. We distinguish InterViews classes into two groups: <!-- /Times-Italic -->
<I>protocols </I><!-- /Times-Roman -->
and <!-- /Times-Italic -->
<I>kits. </I><!-- /Times-Roman -->
A<BR>
protocol defines the set of operations that an object can perform, such as drawing<BR>
or handling input. A kit defines a set of operations for creating other objects. The<BR>
idea of a kit is also sometimes referred to as an #object factoryº. Using kits hides<BR>
the details of object construction and subclassing-instancing tradeoffs made by<BR>
the implementation, as well as providing a higher-level organizational structure to<BR>
the system.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>1.1 Organization<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
In this first chapter, we define the basic notation and classes, as well as give<BR>
an overview of the system by way of several example programs. Chapter 2<BR>
defines the base protocol for user interface objects, called <!-- /Times-Italic -->
<I>Glyph, </I><!-- /Times-Roman -->
which supports<BR>
geometry management, rendering, picking, and structuring multiple glyphs into<BR>
an aggregate. Chapter 3 describes the input event processing model and the<BR>
<!-- /Times-Italic -->
<I>InputHandler </I><!-- /Times-Roman -->
protocol. InputHandler is a descendant of Glyph that receives input<BR>
events. Chapter 4 presents the <!-- /Times-Italic -->
<I>View </I><!-- /Times-Roman -->
protocol, which is derived from InputHandler<BR>
and adds additional operations for creating and updating multiple views of a<BR>
shared data object.<BR>
&nbsp;&nbsp;Chapter 5 defines the <!-- /Times-Italic -->
<I>Window </I><!-- /Times-Roman -->
protocol for associating glyphs with a window<BR>
on the screen and communicating with a window manager. Chapter 6 presents the<BR>
basic protocols for rendering to the screen or a printer.<BR>
&nbsp;&nbsp;Chapter 7 is reserved for the future to describe the <!-- /Times-Italic -->
<I>FigureKit </I><!-- /Times-Roman -->
class that<BR>
will create common 2D graphic objects, such as rectangles, circles, and<BR>
polygons. In traditional graphics terminology, FigureKit will support #structuredº<BR>
graphics, while the basic rendering protocols described in Chapter 6 support<BR>
#immediate-modeº graphics.<BR>
&nbsp;&nbsp;Chapter 8 defines the <!-- /Times-Italic -->
<I>Style </I><!-- /Times-Roman -->
protocol, which manages a collection of named<BR>
attributes with string values. Chapter 9 presents the <!-- /Times-Italic -->
<I>WidgetKit </I><!-- /Times-Roman -->
class for creating<BR>
common user interface components such as buttons, menus, and scrollbars.<BR>
The precise appearance and input behavior of a widget can be adjusted by the
<BR>
<A NAME="PAGE5"></A>
attributes in a style. Chapter 10 presents the <!-- /Times-Italic -->
<I>DialogKit </I><!-- /Times-Roman -->
class for building common<BR>
dialogs.<BR>
&nbsp;&nbsp;Chapter 11 defines the <!-- /Times-Italic -->
<I>LayoutKit </I><!-- /Times-Roman -->
class for creating glyphs that control<BR>
formatting. These objects are based on the TeX document preparation system.<BR>
Chapter 12 describes the <!-- /Times-Italic -->
<I>DocumentKit </I><!-- /Times-Roman -->
class for creating and editing documents.<BR>
&nbsp;&nbsp;Appendix A defines classes for interfacing to the underlying operating system.<BR>
These classes are not intended to provide a complete or standard interface to the<BR>
operating system, but merely a more convenient and portable set of protocols.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>1.2 Notation<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Italic -->
<I>N.B.: The notation in this manual is somewhere between C++ and the OMG<BR>
Interface Definition Language (IDL). We expect to use IDL in the future.<BR>
</I><!-- /Times-Roman -->
We use a syntax similar to C++ to specify the InterViews classes and operations.<BR>
However, the specification of a class here is <!-- /Times-Italic -->
<I>not </I><!-- /Times-Roman -->
identical to its C++ declaration in<BR>
a header file. To make the distinction clear between our specification and C++,<BR>
we use the keyword #interface' instead of #classº. We assume inheritance is<BR>
always #publicº in C++ terminology.<BR>
&nbsp;&nbsp;All operations are assumed public; we do not list the protected or private<BR>
members. We also do not list members that are implicitly part of the<BR>
implementation. For example, C++ destructors are normally public but often<BR>
simply free storage allocated by the object. Thus, there is no need to document<BR>
destructors as part of a class interface.<BR>
&nbsp;&nbsp;Unless explicitly specified as #staticº, all operations are virtual functions in<BR>
C++. In the case of an inherited operation, the choice of whether or not to<BR>
provide the operation may depend on the implementation. We therefore do not<BR>
list inherited operations unless the subclass extends the semantics in some way.<BR>
</FONT>
<FONT SIZE=4>
<!-- /Times-Bold -->
<B>1.2.1 Names<BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
We use identifiers that begin with an upper case letter for types; we use lower<BR>
case for operations and parameters. In type names consisting of multiple words,<BR>
we capitalize the beginning of each word, as in FirstSecondThird. For operations<BR>
or parameters we use underscores to separate words, as in first_second_third.
&nbsp;&nbsp; An<BR>
operation <!-- /Times-Italic -->
<I>f </I><!-- /Times-Roman -->
for a class <!-- /Times-Italic -->
<I>C </I><!-- /Times-Roman -->
is denoted by <!-- /Times-Italic -->
<I>C::f.<BR>
&nbsp;&nbsp;</I><!-- /Times-Roman -->
We assume that some mechanism allows us to use whatever names we wish for<BR>
global symbols; that is, there is no need for a special prefix on all class and<BR>
type names. Ideally, this capability would be provided by the implementation<BR>
language, but this is not yet the case for C++. Currently, the implementation uses<BR>
#define macros to prepend the prefix ``iv'' to all class names and global type<BR>
names. This redefinition is hidden from the programmer, except inasmuch as it<BR>
shows up during debugging. To undefine these macros, a source file must include<BR>
#<InterViews/leave-scope.h>º. After leaving the InterViews scope, InterViews<BR>
names are specified by #_lib_iv(name)º, where <!-- /Times-Italic -->
<I>name </I><!-- /Times-Roman -->
is the class or type name<BR>
&nbsp;&nbsp;1-2
<BR>
<A NAME="PAGE6"></A>
defined in this manual.<BR>
</FONT>
<FONT SIZE=4>
<!-- /Times-Bold -->
<B>1.2.2 Use of const<BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
C++ allows the type modifier #constº to be used in a variety of different ways.<BR>
For concrete objects (int, float, char*), it refers to read-only storage. For abstract<BR>
objects, however, storage access should not be visible in an interface. For<BR>
example, an operation on a transformation matrix could be defined that returns<BR>
whether the matrix is the identity or not. A simple implementation could compute<BR>
the identity test and could be defined as const in the storage sense. However,<BR>
another implementation might cache the result of the test to avoid the overhead of<BR>
the test when the matrix is not changing. This second implementation is not const<BR>
in the storage sense because it modifies the transformation matrix object.<BR>
&nbsp;&nbsp;We use const for operations that do not change the <!-- /Times-Italic -->
<I>behavior </I><!-- /Times-Roman -->
of an object.<BR>
That is, an operation is const if a call to it could be omitted without changing<BR>
the effect of subsequent operations performed on the object. This definition is<BR>
consistent with the notion that a compiler could eliminate redundant calls to the<BR>
same const function. The one important counter-example is reference counting,<BR>
where incrementing and decrementing the reference count of a shared object<BR>
changes its lifetime (an operation that could not be eliminated by the compiler)<BR>
but does not change its behavior (the operation is considered const).<BR>
&nbsp;&nbsp;Using our semantics of const, the transformation matrix identity function<BR>
mentioned above should be defined as const. This approach implies that an<BR>
implementation may be forced to cast the <!-- /Times-Italic -->
<I>this </I><!-- /Times-Roman -->
pointer from const to non-const to<BR>
avoid a compiler error message because C++ compilers normally assume that a<BR>
function should not be const if the function does modifies storage.<BR>
&nbsp;&nbsp;It is also possible (indeed, likely) that a function does not follow our semantics<BR>
of const even though it does not modify the object's storage. If an object contains<BR>
a pointer to another object and an operation performs a non-const operation on<BR>
that object, then the first operation may also need to be defined as non-const.<BR>
</FONT>
<FONT SIZE=4>
<!-- /Times-Bold -->
<B>1.2.3 Common Symbols<BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Several definitions are pervasive throughout the system. These definitions are<BR>
automatically defined as a side effect of using any other InterViews classes.<BR>
The type <!-- /Times-Italic -->
<I>boolean </I><!-- /Times-Roman -->
is defined in the conventional sense of a language such as<BR>
Pascal, as are the constants <!-- /Times-Italic -->
<I>true </I><!-- /Times-Roman -->
and <!-- /Times-Italic -->
<I>false. </I><!-- /Times-Roman -->
The constant <!-- /Times-Italic -->
<I>nil </I><!-- /Times-Roman -->
is presumed to be<BR>
type-equivalent to any pointer type and represents an invalid pointer value. In<BR>
C++, we #define nil to zero.<BR>
&nbsp;&nbsp;The type <!-- /Times-Italic -->
<I>String </I><!-- /Times-Roman -->
is used as a parameter to a number of operations, though no<BR>
specific interface or implementation is presumed. Whereever a string parameter<BR>
appears, one can assume that a C++ #const char*º type can also be passed.<BR>
</FONT>
<FONT SIZE=4>
<!-- /Times-Bold -->
<B>1.2.4 Coordinates<BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Many objects and operations manipulate coordinates. We define the type <!-- /Times-Italic -->
<I>Coord </I><!-- /Times-Roman -->
to<BR>
represent a position or a distance. The default units for a coordinate are #printers<BR>
&nbsp;&nbsp;1-3
<BR>
<A NAME="PAGE7"></A>
pointsº, or 1/72 of an inch. The scaling factor can be customized on a per-screen<BR>
basis.<BR>
&nbsp;&nbsp;Ideally, Coord would be an abstract type with set of operations and conversions<BR>
to concrete types. However, current C++ compilers do not make it practical<BR>
to define a Coord class that is represented as a single word. The current<BR>
implementation therefore defines Coord as the C++ type #float'.<BR>
&nbsp;&nbsp;For applications with simple graphics needs, the use of floating point<BR>
coordinates is typically not a problem. Applications with more sophisticated text<BR>
or graphics usually need to manipulate floating point coordinates anyway.<BR>
&nbsp;&nbsp;The use of non-pixel units allows objects to be resolution-independent, but also<BR>
means that one cannot rely on precise output at low resolutions. Coordinates are<BR>
rounded-off to guarantee that objects that abut in coordinates will abut on the<BR>
screen. This choice means that a one point line might generate one or two pixels,<BR>
depending on where it is on the screen. Objects that need to generate consistent<BR>
pixel sizes can explicitly round to whole-pixel coordinate values using Canvas<BR>
to_pixels_coord.<BR>
</FONT>
<FONT SIZE=4>
<!-- /Times-Bold -->
<B>1.2.5 Dimensions<BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Many composition strategies manipulate coordinates in one dimension. To use a<BR>
single strategy in any dimension, we define the type <!-- /Times-Italic -->
<I>DimensionName </I><!-- /Times-Roman -->
and values <!-- /Times-Italic -->
<I>Dimension_X
 </I><!-- /Times-Roman -->
, <!-- /Times-Italic -->
<I>Dimension_Y, </I><!-- /Times-Roman -->
or <!-- /Times-Italic -->
<I>Dimension_Z. </I><!-- /Times-Roman -->
It is possible that other dimensions<BR>
may be defined in the future. The constant <!-- /Times-Italic -->
<I>Dimension_Undefined </I><!-- /Times-Roman -->
is defined after<BR>
any other dimensions.<BR>
</FONT>
<FONT SIZE=4>
<!-- /Times-Bold -->
<B>1.2.6 Parameter conventions<BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
In specifying an operation, we list only the parameter type unless there are several<BR>
parameters to the operation with the same type. In this case, we list both the type<BR>
and a name for the parameter that clarifies what it is.<BR>
&nbsp;&nbsp;For parameters that are objects, we use a pointer type if the operation may store<BR>
a pointer to the object with a lifetime beyond the operation's activation. If the<BR>
operation will not store a pointer, then we pass a reference type. Therefore, one<BR>
should never pass the expression #&xº for a local or parameter object #xº.<BR>
</FONT>
<FONT SIZE=4>
<!-- /Times-Bold -->
<B>1.2.7 Storage management<BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Because C++ does not provide garbage collection, it is necessary to manage<BR>
shared objects within a program. We make objects easier to share by deriving<BR>
from class Resource, which manages a reference count. If we had garbage<BR>
collection, we would not need the resource class. Therefore, we do not consider<BR>
resource really part of the InterViews programming interface and it does not<BR>
appear in any function type signatures. However, it is necessary to understand<BR>
which objects can be shared and as a practical matter the implementation must<BR>
manage references correctly.<BR>
&nbsp;&nbsp;Figure 1.1 shows the Resource class interface. Every resource has a reference<BR><BR>
&nbsp;&nbsp;1-4
<BR>
<A NAME="PAGE8"></A>
count that is initially zero and must be explicitly incremented by calling<BR>
Resource::ref. The reason the count is initially zero is that an object is often<BR>
created and immediately passed as a parameter to another object that stores the<BR>
reference. Since the receiver must reference the parameter anyway, it is confusing<BR>
to force the creator to unreference the resource after passing it.<BR>
&nbsp;&nbsp;The C++ delete operator should not be used on resources directly; instead,<BR>
Resource::unref or Resource::unref_deferred should be called to decrement the<BR>
reference count of an object. If the count is no longer positive, then the resource's<BR>
cleanup operation will be called. In the case of Resource::unref, the object is<BR>
immediately destroyed. In the case of Resource::unref_deferred, the object will<BR>
be put on a queue of objects to be destroyed in order the next time Resource::flush<BR>
is called. Resource deferral is useful when an object initiates a delete on one of its<BR>
ancestors or some other object with an active member function.<BR>
</FONT>
<FONT SIZE=4>
<!-- /Times-Bold -->
<B>1.2.8 Callbacks<BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
C++ provides a pointer-to-function type, but often one wishes to encapsulate an<BR>
object and a pointer to a member function to call on the object. Our approach is<BR>
to define a base class containing the callback signature and a parameterized<BR>
subclass for a callback to an object of a specific type. For example, the <!-- /Times-Italic -->
<I>action<BR>
</I><!-- /Times-Roman -->
class defines a single operation, Action::execute, with no parameters and no<BR>
return value. A <!-- /Times-Italic -->
<I>macro </I><!-- /Times-Roman -->
is an action that contains a list of actions, each of which<BR>
is executed in order. An <!-- /Times-Italic -->
<I>action callback </I><!-- /Times-Roman -->
is the subclass that is expanded for<BR>
each destination type. The current implementation uses preprocessor macros,<BR>
but will use templates in the future. Figure 1.2 shows the action, macro, and<BR>
action-callback class interfaces.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>1.3 Basic concepts<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
The goal of InterViews is to make it easy to compose user interfaces from<BR>
reusable components. The central class for physical composition is Glyph because<BR>
it defines the geometry of a user interface object. The central class for logical<BR>
composition is InputHandler because it defines the input handling policy and<BR>
update management. InputHandler is a subclass of glyph, normally delegating its<BR><BR>
&nbsp;&nbsp;1-5
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
interface
&nbsp;&nbsp; 
&nbsp;&nbsp; Resource {<BR>
&nbsp;&nbsp;static void ref(const Resource*);<BR>
&nbsp;&nbsp;static void unref(const Resource*);<BR>
&nbsp;&nbsp;static void unref_deferred(const
&nbsp;&nbsp; Resource*);<BR>
&nbsp;&nbsp;static void flush();
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;void cleanup();<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 1.1:
&nbsp;&nbsp; 
&nbsp;&nbsp; 
&nbsp;&nbsp; Resource class interface
<BR>
<A NAME="PAGE9"></A>
</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
geometry and appearance to another glyph.<BR>
&nbsp;&nbsp;The Canvas class defines a 2-dimensional surface upon to which a group of<BR>
glyphs are attached. The glyphs negotiate for space on the canvas, draw on the<BR>
canvas to refresh their appearance, and damage the canvas to cause an update<BR>
traversal.<BR>
&nbsp;&nbsp;The Window class creates a canvas for a top-level input handler and allows<BR>
the user to control the canvas on a screen through a window manager. The<BR>
window class does not define a window management policy, only the mechanism<BR>
for communicating appropriate information between a window manager and the<BR>
glyphs.<BR>
&nbsp;&nbsp;The InterViews input model is ``top-down''. That is, an input event is first<BR>
received by the appropriate window as determined by the window manager. The<BR>
receiving window passes the event to the root input handler, which may pass it<BR>
down to a nested input handler.<BR>
</FONT>
<FONT SIZE=4>
<!-- /Times-Bold -->
<B>1.3.1 Main event loop<BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Every application creates a Session object to run an event dispatching loop.<BR>
Sessions initially attach to the user's display and can attach to additional displays.<BR>
A session defines a root Style object derived from user customization files and<BR>
command-line arguments. Styles define named attributes with string values,<BR>
wildcarding for matching classes of objects, and quick access to common<BR>
attributes such as fonts and colors. Figure 1.3 shows the session protocol.<BR>
&nbsp;&nbsp;The session is given an alias (class name) for the root style, an array of<BR>
command-line arguments, an optional argument description, and optional initial<BR>
style settings. The root style's name comes from the #-nameº command-line<BR>
option (if given), or the environment variable RESOURCE_NAME (if defined),<BR>
or the value of argv[0] with leading path entries stripped.<BR>
&nbsp;&nbsp;1-6
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
typedef long MacroIndex;
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;interface Action : Resource {<BR>
&nbsp;&nbsp;void execute() =
&nbsp;&nbsp; 
&nbsp;&nbsp; 0;<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;interface Macro : Action {<BR>
&nbsp;&nbsp;Macro(Action* = nil, Action* = nil, Action* = nil, Action* = nil);<BR>
&nbsp;&nbsp;void prepend(Action*);<BR>
&nbsp;&nbsp;void append(Action*);<BR>
&nbsp;&nbsp;void insert(MacroIndex, Action*);<BR>
&nbsp;&nbsp;void remove(MacroIndex);<BR>
&nbsp;&nbsp;MacroIndex count() const;<BR>
&nbsp;&nbsp;Action* action(MacroIndex) const;<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;interface ActionCallback(T) : Action {<BR>
&nbsp;&nbsp;ActionCallback(T)(T*, void (T::*)());<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 1.2: Action and related class interfaces.
<BR>
<A NAME="PAGE10"></A>
&nbsp;&nbsp;</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
The option description is an array of structures that describe command-line<BR>
arguments. The structure contains four fields: a <!-- /Times-Italic -->
<I>name </I><!-- /Times-Roman -->
that is the command-line<BR>
string, a <!-- /Times-Italic -->
<I>path </I><!-- /Times-Roman -->
specifying a style attribute, a <!-- /Times-Italic -->
<I>format </I><!-- /Times-Roman -->
specifying where the associated<BR>
value is, and a default <!-- /Times-Italic -->
<I>value. </I><!-- /Times-Roman -->
Valid formats are OptionPropertyNext (use the next<BR>
argument as an attribute-value pair), OptionValueNext (use the next argument<BR>
as the value), OptionValueImplicit (use the default value), OptionValueIsArg<BR>
(use the agument as the value), and OptionValueAfter (use the remainder of the<BR>
argument as the value). If a command-line argument is found that matches an<BR>
option description, it will be interpreted and removed from argv. The agument<BR>
count (argc) will be set to the number of uninterpreted command-line arguments.<BR>
&nbsp;&nbsp;In addition to the program-specified options, the Session constructor<BR>
automatically matches the options listed in Table 1.1. The optional initial style<BR>
settings are specified by a nil-terminated array of pairs <!-- /Times-Italic -->
<I><s1,s2>, </I><!-- /Times-Roman -->
where <!-- /Times-Italic -->
<I>s1 </I><!-- /Times-Roman -->
is an<BR>
attribute name and <!-- /Times-Italic -->
<I>s2 </I><!-- /Times-Roman -->
is the value. User defaults will override any initial settings,<BR><BR>
&nbsp;&nbsp;1-7
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
struct PropertyData {<BR>
&nbsp;&nbsp;const char* path;<BR>
&nbsp;&nbsp;const char* value;<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;struct OptionDesc {<BR>
&nbsp;&nbsp;const char* name;<BR>
&nbsp;&nbsp;const char* path;<BR>
&nbsp;&nbsp;OptionStyle format;<BR>
&nbsp;&nbsp;const char* value;<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;interface Session {<BR>
&nbsp;&nbsp;Session(<BR>
&nbsp;&nbsp;const char* name, int& argc, char** argv<BR>
&nbsp;&nbsp;const OptionDesc* = nil, const PropertyData* = nil<BR>
&nbsp;&nbsp;);<BR>
&nbsp;&nbsp;static Session* instance();<BR>
&nbsp;&nbsp;int argc() const;<BR>
&nbsp;&nbsp;char** argv() const;<BR>
&nbsp;&nbsp;Style* style() const;<BR>
&nbsp;&nbsp;void default_display(Display*);<BR>
&nbsp;&nbsp;Display* default_display() const;<BR>
&nbsp;&nbsp;Display* connect(const String&);<BR>
&nbsp;&nbsp;Display* connect(const char*);<BR>
&nbsp;&nbsp;void disconnect(Display*);<BR>
&nbsp;&nbsp;int run();<BR>
&nbsp;&nbsp;int run_window(Window*);<BR>
&nbsp;&nbsp;void quit();<BR>
&nbsp;&nbsp;boolean done();<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 1.3: Session protocol<BR><BR>
&nbsp;&nbsp;Figure 1.4:
<BR>
<A NAME="PAGE11"></A>
</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
and command-line arguments will override user defaults.<BR>
</FONT>
<FONT SIZE=4>
<!-- /Times-Bold -->
<B>1.3.2 Common widgets<BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
InterViews provides common behavior objects, such as buttons and menus, which<BR>
are built using glyphs and input handlers. Unlike many other toolkits, InterViews<BR>
objects are cheap enough that behavior objects are separate from appearance<BR>
objects. For example, the button class is given a separate glyph that denotes its<BR>
appearance; the button only implements input behavior.<BR>
&nbsp;&nbsp;This approach of separating input and output objects makes the toolkit more<BR>
flexible and the individual objects simpler, but it can make the task of constructing<BR>
higher-level user interface objects more confusing. In particular, it becomes less<BR>
obvious whether it is appropriate to subclass or instance to create a particular<BR>
component.<BR>
&nbsp;&nbsp;InterViews provides a widget kit object that encapsulates these decisions in a<BR>
single programming interface while allowing various appearances and behaviors.<BR>
A widget kit is an object that creates common user interface objects such as<BR>
buttons, scrollbars, and menus. For example, a push button has button behavior, a<BR>
&nbsp;&nbsp;1-8
&nbsp;&nbsp; 
&nbsp;&nbsp; 
&nbsp;&nbsp; 
&nbsp;&nbsp; 
&nbsp;&nbsp; 
&nbsp;&nbsp; 
&nbsp;&nbsp; 
&nbsp;&nbsp; 
&nbsp;&nbsp; 
&nbsp;&nbsp; 
&nbsp;&nbsp; 
&nbsp;&nbsp; 
&nbsp;&nbsp; 
&nbsp;&nbsp; 
&nbsp;&nbsp; 
&nbsp;&nbsp; 
&nbsp;&nbsp; 
&nbsp;&nbsp; 
&nbsp;&nbsp; 
&nbsp;&nbsp; 
&nbsp;&nbsp; 
&nbsp;&nbsp; 
&nbsp;&nbsp; 
&nbsp;&nbsp; 
&nbsp;&nbsp; 
&nbsp;&nbsp; 
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;-background next argument sets the background color<BR>
&nbsp;&nbsp;-bg same as -background<BR>
&nbsp;&nbsp;-dbuf double-buffer windows by default<BR>
&nbsp;&nbsp;-display next argument specifies the target workstation display<BR>
&nbsp;&nbsp;-dpi next argument is coordinates-to-pixels ratio<BR>
&nbsp;&nbsp;-fg same as -foreground<BR>
&nbsp;&nbsp;-flat next argument sets the base color for bevels<BR>
&nbsp;&nbsp;-fn same as -font<BR>
&nbsp;&nbsp;-font next argument sets the default text font<BR>
&nbsp;&nbsp;-foreground next argument sets the foreground color<BR>
&nbsp;&nbsp;-geometry next argument sets the first window's position and size<BR>
&nbsp;&nbsp;-iconic starts up first window in iconic form<BR>
&nbsp;&nbsp;-malloc run with memory-management debugging on<BR>
&nbsp;&nbsp;-monochrome use monochrome style<BR>
&nbsp;&nbsp;-motif use Motif style<BR>
&nbsp;&nbsp;-name next argument sets the instance name of the session<BR>
&nbsp;&nbsp;-nodbuf do not double-buffer windows<BR>
&nbsp;&nbsp;-openlook use OpenLook style<BR>
&nbsp;&nbsp;-synchronous force synchronous operation with the window system<BR>
&nbsp;&nbsp;-title next argument sets the session's default title bar name<BR>
&nbsp;&nbsp;-visual next argument is visual class to use for windows<BR>
&nbsp;&nbsp;-visual_id next argument is visual id number to use for windows<BR>
&nbsp;&nbsp;-xrm next argument is #name:valueº; sets named attribute<BR>
&nbsp;&nbsp;Table 1.1: Predefined command-line options
<BR>
<A NAME="PAGE12"></A>
beveled or highlighted appearance when pressed, and a style for customization.<BR>
The WidgetKit class provides a function to create a push button object; the<BR>
implementation is free to compose what objects are necessary to provide the<BR>
appropriate functionality. Each application normally creates a single WidgetKit<BR>
object, which is typically a subclass defined for a particular look-and-feel<BR>
such as OpenLook or Motif. The application can call the static function<BR>
WidgetKit:::instance to return the object and therefore be unaware which specific<BR>
look-and-feel is being used.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>1.4 A simple example<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Figure 1.5 shows a simple InterViews application that display the text #hi mom!º<BR>
in a window. The application creates a session and runs it starting with a window<BR>
containing the text over a background. The window is an #application windowº,<BR>
meaning it is recognized by other desktop services (window manager, session<BR>
manager) as the main window for the application.<BR>
&nbsp;&nbsp;The window contains a background that contains a label. A background glyph<BR>
paints a given color behind its contents. The label's font and color are obtained<BR>
from the default style for the session.<BR>
&nbsp;&nbsp;This application does not handle user input. It must therefore be terminated<BR>
externally, either from a window manager menu or through the system.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>1.5 Geometry management<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
See iv/src/examples/box[12].<BR><BR><BR><BR><BR>
&nbsp;&nbsp;1-9
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
#include <IV-look/kit.h>
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;#include <InterViews/background.h><BR>
&nbsp;&nbsp;#include <InterViews/session.h><BR>
&nbsp;&nbsp;#include <InterViews/window.h><BR>
&nbsp;&nbsp;int main(int argc, char** argv) {<BR>
&nbsp;&nbsp;Session* session = new Session("Himom", argc, argv);<BR>
&nbsp;&nbsp;WidgetKit& kit = *WidgetKit::instance();<BR>
&nbsp;&nbsp;return session->run_window(<BR>
&nbsp;&nbsp;new ApplicationWindow(<BR>
&nbsp;&nbsp;new Background(<BR>
&nbsp;&nbsp;kit.label("hi mom!"), kit.background()<BR>
&nbsp;&nbsp;)<BR>
&nbsp;&nbsp;)<BR>
&nbsp;&nbsp;);<BR>
&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;Figure 1.5: InterViews "hi mom!" program.
<BR>
<A NAME="PAGE13"></A>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>1.6 Creating a push button<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
See iv/src/examples/button[123].<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>1.7 Summary<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
This chapter has presented a broad overview of the InterViews architecture,<BR>
introducing the basic concepts and giving some simple examples. In the next<BR>
chapter, we focus on the semantics of glyphs as the smallest unit of user interface<BR>
construction.<BR><BR><BR><BR><BR>
&nbsp;&nbsp;1-10
<BR>
<A NAME="PAGE14"></A>
</FONT>
<FONT SIZE=9>
<!-- /Times-Bold -->
<B>Chapter 2<BR>
Glyphs<BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Glyphs are the basic building blocks for the presentation side of a user<BR>
interface, providing a unified substrate for interactive objects, structured graphics,<BR>
and formatted text. The glyph protocol supports geometry, drawing, picking,<BR>
composition, and structure. Glyph subclasses provide higher-level operations,<BR>
such as input handling and update management.<BR>
&nbsp;&nbsp;The base class defines no storage and operations are passed contextual<BR>
information during rendering. Thus, glyphs may be shared and a glyph structure<BR>
need not be strictly hierarchical; it may be a directed acyclic graph. Figure 2.1<BR>
shows the glyph protocol.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>2.1 Geometry management<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Glyph::request asks a glyph to specify its desired geometry. This operation should<BR>
be fast to allow a composite glyph to compute rather than store the desired<BR>
geometry of its components. Glyph::allocate notifies a glyph that a portion of the<BR>
canvas has been allocated for it and returns an area that represents a conservative<BR>
estimate of the actual area where the glyph will draw.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>2.2 Drawing<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Glyph::draw displays the glyph on the canvas at the position and size specified by<BR>
the allocation. No clipping or translation is implicit in this operation±the
&nbsp;&nbsp; canvas is<BR>
the entire drawing area and the allocation is in canvas coordinates. However, a<BR>
composite glyph may set clipping on the canvas before drawing its children.<BR>
&nbsp;&nbsp;There is no guarantee that a call to draw will affect the screen immediately<BR>
because of the possibility (indeed, likelihood) that the canvas is double-buffered.<BR>
Furthermore, drawing order is important for glyphs when they are partially<BR>
transparent and are drawn in the same plane. A glyph's draw operation therefore<BR>
should not be called directly, but rather is implicitly called during screen update.<BR>
&nbsp;&nbsp;Glyph::undraw notifies a glyph that its allocation is no longer valid. This<BR>
operation is generally a performance hint to free cached information associated<BR>
with drawing or inhibit some operation that is unnecessary while the glyph is not<BR>
visible, such as cursor blinking. Glyph::undraw is <!-- /Times-Italic -->
<I>not </I><!-- /Times-Roman -->
to be used when a glyph's<BR>
allocation changes; in that case, allocate and draw can simply be called with<BR>
different parameters.<BR>
&nbsp;&nbsp;Glyph::print generates a representation of the glyph graph suitable for printing.<BR>
The canvas and printer rendering interfaces are identical, and the default<BR>
&nbsp;&nbsp;2- 
<BR>
<A NAME="PAGE15"></A>
implementation of print is simply to call draw. Most glyphs therefore need not<BR>
define a print operation. The reason for a distinct print operation is to allow<BR>
a glyph to use different rendering requests for the screen and a printer. For<BR>
example, a glyph might use 3D requests to the screen, or might compute more<BR>
precise output for printing.<BR>
&nbsp;&nbsp;Glyph::pick finds the glyphs that intersect a point or rectangle specified<BR>
in canvas-relative coordinates. Conceptually, picking is like drawing and<BR>
determining what glyphs intersect the specified point or rectangle. The<BR>
coordinates are contained in the hit parameter. The depth parameter specifies<BR>
which level in the Hit object to store the intersecting glyphs. When pick returns,<BR>
the Hit parameter contains the glyphs that were hit.<BR>
&nbsp;&nbsp;Figure 2.2 shows the hit protocol. A hit object may be constructed with a point,<BR>
a rectangle, or an event. In the case of the event, the event pointer coordinates are<BR>
used to detect intersection and glyphs can associate a handler with the pick result.<BR>
&nbsp;&nbsp;Hit::event, Hit::left, Hit::bottom, Hit::right, Hit::top return information about<BR>
the specified hit area. Hit::event returns nil if the point or rectangle constructors<BR>
were used.<BR>
&nbsp;&nbsp;Hit::push_transform, Hit::transform, and Hit::pop_transform modify the current<BR>
intersection area for picking. These operations are just like the canvas operations<BR>
with the same names except they apply to the hit information instead of a canvas.<BR>
&nbsp;&nbsp;Glyphs record information in a hit object with Hit::begin, Hit::target and
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
typedef long GlyphIndex;<BR>
&nbsp;&nbsp;typedef unsigned int GlyphBreakType;<BR>
&nbsp;&nbsp;interface Glyph : Resource {<BR>
&nbsp;&nbsp;void request(Requisition&) const;<BR>
&nbsp;&nbsp;void allocate(Canvas*, const Allocation&, Extension&);<BR>
&nbsp;&nbsp;void draw(Canvas*, const Allocation&) const;<BR>
&nbsp;&nbsp;void undraw();<BR>
&nbsp;&nbsp;void print(Printer*, const Allocation&) const;<BR>
&nbsp;&nbsp;void pick(Canvas*, const Allocation&, int depth, Hit&);<BR>
&nbsp;&nbsp;enum { no_break, pre_break, in_break, post_break };<BR>
&nbsp;&nbsp;Glyph* compose(GlyphBreakType) const;<BR>
&nbsp;&nbsp;void append(Glyph*);<BR>
&nbsp;&nbsp;void prepend(Glyph*);<BR>
&nbsp;&nbsp;void insert(GlyphIndex, Glyph*);<BR>
&nbsp;&nbsp;void remove(GlyphIndex);<BR>
&nbsp;&nbsp;void replace(GlyphIndex, Glyph*);<BR>
&nbsp;&nbsp;void change(GlyphIndext);<BR>
&nbsp;&nbsp;GlyphIndex count() const;<BR>
&nbsp;&nbsp;Glyph* component(GlyphIndex) const;<BR>
&nbsp;&nbsp;void allotment(GlyphIndext, DimensionName, Allotment&) const;<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 2.1: Glyph protocol
&nbsp;&nbsp;<BR><BR><BR><BR><BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
2- 
<BR>
<A NAME="PAGE16"></A>
Hit::end. Hit::target indicates that a glyph's output intersects the hit region.<BR>
Hit::begin and Hit::end are used by composite glyphs that should be on the hit<BR>
list if and only if one of their components calls Hit::target. The parameters to<BR>
Hit::begin and Hit::target have the same meaning. The depth is the level in the hit<BR>
list where the information should be stored. The glyph is the hit glyph. The index<BR>
is additional information about the hit. For a composite glyph, this is typically<BR>
the index of the hit child. Hit::remove and Hit::retarget modify the current hit<BR>
information.<BR>
&nbsp;&nbsp;The remaining hit operations return information about a pick. The result is<BR>
a list of paths, each of which contains a list of glyphs terminating with the<BR>
glyphs that would draw through the pick region. Hit::count returns the number of<BR>
paths. Hit::depth returns the index of the last glyph in a specified path. The path<BR>
corresponding to the top-most glyph is in position zero. Hit::target and Hit::index<BR>
return the information for a given path and depth.<BR>
&nbsp;&nbsp;If a pick is done on a hit object constructed from an event, and one or more<BR>
glyphs find the event of interest, they will associate a handler with the hit object.<BR>
Hit::handler returns the top-most, deepest handler, or nil if there is none.<BR><BR><BR>
&nbsp;&nbsp;2- 3
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
interface Hit {<BR>
&nbsp;&nbsp;Hit(const Event*);<BR>
&nbsp;&nbsp;Hit(Coord x, Coord y);<BR>
&nbsp;&nbsp;Hit(Coord left, Coord bottom, Coord right, Coord top);<BR>
&nbsp;&nbsp;const Event* event() const;<BR>
&nbsp;&nbsp;Coord left() const, bottom() const, right() const, top() const;<BR>
&nbsp;&nbsp;void push_transform();<BR>
&nbsp;&nbsp;void transform(const Transformer&);<BR>
&nbsp;&nbsp;void pop_transform();<BR>
&nbsp;&nbsp;void begin(int depth, Glyph*, GlyphIndex, Handler* = nil);<BR>
&nbsp;&nbsp;void target(int depth, Glyph*, GlyphIndex, Handler* = nil);<BR>
&nbsp;&nbsp;void end();<BR>
&nbsp;&nbsp;void remove(int depth, GlyphIndex target = 0);<BR>
&nbsp;&nbsp;void retarget(<BR>
&nbsp;&nbsp;int depth, Glyph*, GlyphIndex, Handler* = nil, GlyphIndex = 0<BR>
&nbsp;&nbsp;);<BR>
&nbsp;&nbsp;boolean any() const;<BR>
&nbsp;&nbsp;int count() const;<BR>
&nbsp;&nbsp;int depth(GlyphIndex target = 0) const;<BR>
&nbsp;&nbsp;Glyph* target(int depth, GlyphIndex target = 0) const;<BR>
&nbsp;&nbsp;GlyphIndex index(int depth, GlyphIndex = 0) const;<BR>
&nbsp;&nbsp;Handler* handler() const;<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 2.2: Hit class interface.
<BR>
<A NAME="PAGE17"></A>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>2.3 Composition<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
BreakType defines the choices for how a composite glyph might break a group of<BR>
glyphs in a layout. The break may occur before a glyph (pre_break), in the glyph<BR>
(in_break), or after the glyph (post_break).<BR>
&nbsp;&nbsp;Glyph::compose returns a new glyph that should be used to replace the target<BR>
glyph when the break occurs. For example, discretionary white space in a<BR>
document will turn into zero-size glue if a line-break or page-break occurs on it.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>2.4 Structure<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Several operations are provided to manipulate the list of components that make up<BR>
a composite glyph. Primitive glyphs ignore these operations, while monoglyphs<BR>
pass the operation through to their body. A monoglyph is therefore ``transparent''<BR>
with respect to structure, allowing one to put a monoglyph around a composite and<BR>
pass the result to another object that manipulates the components of the composite.<BR>
&nbsp;&nbsp;Glyph::append (prepend) adds a given glyph to the end (beginning) of the<BR>
component list. Glyph::insert adds a given glyph at a specified index in the list.<BR>
Glyph::remove removes the glyph at the specified index. Glyph::replace replaces<BR>
the glyph at the specified index with the given glyph. Glyph::change notifies a<BR>
glyph that its component at the given index has changed, and therefore it might be<BR>
necessary to reallocate it.<BR>
&nbsp;&nbsp;Glyph::count returns the number of glyphs in its component list.<BR>
Glyph::component returns the glyph in its component list at the given index.<BR>
Glyph::allotment returns the allocation information in the given dimension for the<BR>
glyph at the given index in its component list.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>2.5 Requisitions<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Glyphs define their geometric needs with a <!-- /Times-Italic -->
<I>requisition, </I><!-- /Times-Roman -->
which specifies a<BR>
<!-- /Times-Italic -->
<I>requirement </I><!-- /Times-Roman -->
in each dimension. Figure 2.3 shows the requisition and requirement<BR>
class interfaces.<BR>
&nbsp;&nbsp;Requisition::penalty is overloaded to set or get the penalty associated with<BR>
choosing a break at the position defined by the requisition. Requisition::require<BR>
sets a requirement in a given dimension. Requisition::requirement returns the<BR>
requirement for a given dimension.<BR>
&nbsp;&nbsp;A requirement consists of a natural size, stretchability, shrinkability, and<BR>
alignment. The maximum size is the natural size plus the stretchability; the<BR>
minimum is the natural minus the shrinkability. It is possible to have negative<BR>
minimum sizes. The alignment is a fraction that indicates the origin of the area.<BR>
An alignment of zero means the origin is at the lower coordinate value; an<BR><BR>
&nbsp;&nbsp;2- 
<BR>
<A NAME="PAGE18"></A>
alignment of one means it is at the upper coordinate value.<BR>
&nbsp;&nbsp;There are four constructors for requirement: with no parameters, which makes<BR>
the natural size undefined and the other fields zero; with a single coordinate that<BR>
defines the natural size and makes the other fields zero; with explicit coordinates<BR>
for the natural size, stretchability, and shrinkability, and a float value for the<BR>
alignment; and with explicit coordinates for specifying the distances on each side<BR>
of the origin.<BR>
&nbsp;&nbsp;Requirement::equals compares two requirements (the target object and the<BR>
argument) using a given tolerance for the individual coordinate comparisons.<BR>
Requirement::defined returns whether the natural size has been defined. The<BR>
overloaded functions natural, stretch, shrink, and alignment set and get the<BR>
respective values.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>2.6 Allocations<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
The actual size a glyph is given is defined by an <!-- /Times-Italic -->
<I>allocation, </I><!-- /Times-Roman -->
which specifies<BR>
an <!-- /Times-Italic -->
<I>allotment </I><!-- /Times-Roman -->
in each dimension. Figure 2.4 shows the allocation and allotment<BR>
class interfaces. An allotment specifies one dimension of an allocation with three<BR>
values: an origin, a span, and an alignment. The origin is a position within the<BR>
allotment and the span is the size of the allotment. The alignment is a fraction<BR>
specifying the position of the origin. For example, if the origin is 1, span is 10,<BR><BR>
&nbsp;&nbsp;2- 5
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
interface Requisition {<BR>
&nbsp;&nbsp;void penalty(int);<BR>
&nbsp;&nbsp;int penalty() const;<BR>
&nbsp;&nbsp;boolean equals(const Requisition&, float epsilon) const;<BR>
&nbsp;&nbsp;void require(DimensionName, const Requirement&);<BR>
&nbsp;&nbsp;const Requirement& requirement(DimensionName) const;<BR>
&nbsp;&nbsp;Requirement& requirement(DimensionName);<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;interface Requirement {<BR>
&nbsp;&nbsp;Requirement(Coord natural);<BR>
&nbsp;&nbsp;Requirement(Coord natural, Coord stretch, Coord shrink, float);<BR>
&nbsp;&nbsp;Requirement(<BR>
&nbsp;&nbsp;Coord natural_lead, Coord max_lead, Coord min_lead,<BR>
&nbsp;&nbsp;Coord natural_trail, Coord max_trail, Coord min_trail<BR>
&nbsp;&nbsp;);<BR>
&nbsp;&nbsp;boolean equals(const Requirement&, float epsilon) const;<BR>
&nbsp;&nbsp;boolean defined() const;<BR>
&nbsp;&nbsp;void natural(Coord), stretch(Coord), shrink(Coord);<BR>
&nbsp;&nbsp;Coord natural() const, stretch() const, shrink() const;<BR>
&nbsp;&nbsp;void alignment(float);<BR>
&nbsp;&nbsp;float alignment() const;<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 2.3: Requisition and Requirement classes.
<BR>
<A NAME="PAGE19"></A>
</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
and alignment is 0.5, then the allotment begins at -4 and ends at 6.<BR>
&nbsp;&nbsp;The allocation constructor initializes each allotment to have zero values.<BR>
Allocation::equals compares two allocations using a tolerance for individual<BR>
coordinate comparisions. Allocation::allot sets the allotment for a given<BR>
dimension. Allocation::allotment returns the allotment for a specified dimension.<BR>
&nbsp;&nbsp;Several operations are provided for convenience when accessing allotments in<BR>
the X and Y dimensions. Allocation::x and Allocation::y return the X and Y<BR>
origins. Allocation::left and Allocation::right return the X dimension end-points,<BR>
Allocation::bottom and Allocation::top return the Y dimension end-points.<BR>
&nbsp;&nbsp;The Allotment class also provides an equals operation for comparing two<BR>
allotments with a given tolerance. Allotment::origin, Allotment::span, and<BR>
Allotment::alignment are overloaded names for setting and getting the allotment<BR>
values. Allotment::offset adds to the current origin.<BR>
&nbsp;&nbsp;Allotment::begin and Allotment::end return the end-points of an allotment.<BR>
Allotment::begin is equivalent to the origin minus the alignment times the span.<BR>
Allotment::end is equivalent to Allotment::begin plus the span.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>2.7 Extensions<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
The area that defines where a glyph actually draws is called an <!-- /Times-Italic -->
<I>extension. </I><!-- /Times-Roman -->
This<BR>
area is typically used for update. If a glyph needs to be completely redrawn, the<BR>
glyph's extension must be damaged.<BR>
&nbsp;&nbsp;Extensions are represented in device-independent units, but must be rounded<BR><BR>
&nbsp;&nbsp;2- 6
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
interface Allocation {<BR>
&nbsp;&nbsp;boolean equals(const Allocation&, float epsilon) const;<BR>
&nbsp;&nbsp;void allot(DimensionName, const Allotment&);<BR>
&nbsp;&nbsp;Allotment& allotment(DimensionName);<BR>
&nbsp;&nbsp;const Allotment& allotment(DimensionName) const;<BR>
&nbsp;&nbsp;Coord x() const, y() const;<BR>
&nbsp;&nbsp;Coord left() const, right() const, bottom() const, top() const;<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;interface Allotment {<BR>
&nbsp;&nbsp;Allotment(Coord origin, Coord span, float alignment);<BR>
&nbsp;&nbsp;boolean equals(const Allotment&, float epsilon) const;<BR>
&nbsp;&nbsp;void origin(Coord), offset(Coord), span(Coord);<BR>
&nbsp;&nbsp;Coord origin() const, span() const;<BR>
&nbsp;&nbsp;void alignment(float);<BR>
&nbsp;&nbsp;float alignment() const;<BR>
&nbsp;&nbsp;Coord begin() const;<BR>
&nbsp;&nbsp;Coord end() const;<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 2.4: Allocation and allotment class interfaces
<BR>
<A NAME="PAGE20"></A>
</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
out to the nearest device-dependent units. For example, if one of the bounds for<BR>
one glyph's extension is 10.2 and another is 10.5, we would need to redraw<BR>
both glyphs if the bounds translate to the same pixel coordinate. Because<BR>
extensions are typically used to damage a canvas, the extension coordinates are<BR>
canvas-relative.<BR>
&nbsp;&nbsp;A glyph computes its extension as part of the allocate operation. Typically, a<BR>
glyph will simply return its allocation rounded according to the canvas.<BR>
&nbsp;&nbsp;Figure 2.5 shows the Extension protocol. Extension::set initializes an extension<BR>
to the given allocation transformed and rounded for the given canvas.<BR>
Extension::clear sets an extension to be an empty area. Extension::merge extends<BR>
an extension to include a new area in addition to its current one.<BR>
&nbsp;&nbsp;Extension::set_xy and Extension::merge_xy are short-hand for adjusting an<BR>
extension to include a given bounding box. Extension::left, bottom, right, and top<BR>
return the bounding box.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>2.8 Polyglyphs<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
A composite glyph contains one or more components. Any glyph subclass<BR>
may contain subcomponents, but composite glyphs are typically derived from<BR>
PolyGlyph to be able to store and retrieve their children.<BR>
&nbsp;&nbsp;The PolyGlyph protocol, shown in Figure 2.6 adds one operation beyond the<BR>
base class, PolyGlyph::modified(GlyphIndex), which notifies the glyph that the<BR>
given component has changed. This operation is called when a glyph is inserted<BR>
or removed from the composite.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>2.9 MonoGlyphs<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
MonoGlyph is an abstract class for glyphs that contain a single glyph, called its<BR>
<!-- /Times-Italic -->
<I>body. </I><!-- /Times-Roman -->
The default behavior of monoglyphs is to pass operations on to the body.<BR>
For example, the implementation of MonoGlyph::draw simply calls draw on<BR>
&nbsp;&nbsp;2- 7
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
interface Extension {<BR>
&nbsp;&nbsp;void set(Canvas*, const Allocation&);<BR>
&nbsp;&nbsp;void set_xy(Canvas*, Coord left, Coord bottom, Coord right, Coord top);<BR>
&nbsp;&nbsp;void clear();<BR>
&nbsp;&nbsp;void merge(const Extension&);<BR>
&nbsp;&nbsp;void merge(Canvas*, const Allocation&);<BR>
&nbsp;&nbsp;void merge_xy(<BR>
&nbsp;&nbsp;Canvas*, Coord left, Coord bottom, Coord right, Coord top<BR>
&nbsp;&nbsp;);<BR>
&nbsp;&nbsp;Coord left() const, bottom() const, right() const, top() const;<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 2.5: Extension protocol
<BR>
<A NAME="PAGE21"></A>
</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
the body. This feature is very useful because it means that a monoglyph can<BR>
affect one aspect of the body's behavior without changing other aspects. In<BR>
particular, monoglyphs usually do not change structure management. Therefore, a<BR>
monoglyph can be #wrappedº around a composite glyph and the result passed to<BR>
an object that modifies the structure of the composite without knowing about the<BR>
presence of the monoglyph. For example, suppose a prototype menu is built and<BR>
returned to a function that appends the items. All the function need assume is that<BR>
the prototype is some glyph; it can use Glyph::append to put in the items. The<BR>
arrangement of the items will be defined by the aggregate and any additional<BR>
decoration, such as a 3D borderframe or shadow, can be wrapped around the<BR>
aggregate independently.<BR>
&nbsp;&nbsp;Figure 2.7 shows the MonoGlyph base class interface. A non-nil glyph specifies<BR>
the initial body. MonoGlyph::body is overloaded to set and return the body.<BR>
</FONT>
<FONT SIZE=4>
<!-- /Times-Bold -->
<B>2.9.1 Patches<BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
A patch stores its canvas and allocation for subsequent use to update its body. A<BR>
patch is useful for objects that need to be redrawn independently, such as those<BR>
that depend on some external data. Typically, a patch appears in the middle of a<BR>
glyph instance graph, where a change would be too expensive to redraw the entire<BR>
graph.<BR>
&nbsp;&nbsp;Figure 2.8 shows the Patch class interface. Patch::canvas and Patch::allocation<BR>
return the canvas and allocation most recently passed to Patch::draw.<BR>
Patch::reallocate calls allocate on the body using the current allocation, usually<BR>
because the body has changed in some way and will allocate its itself differently.<BR>
Patch::redraw calls draw on the body using the current allocation. Patch::repick<BR>
returns the result of calling pick on the body with the current canvas and allocation.<BR><BR><BR><BR><BR>
&nbsp;&nbsp;2- 8
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
interface PolyGlyph : Glyph {<BR>
&nbsp;&nbsp;PolyGlyph(GlyphIndex initial_size = 10);<BR>
&nbsp;&nbsp;void modified(GlyphIndex);<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 2.6: Polyglyph protocol
&nbsp;&nbsp; 
&nbsp;&nbsp;<BR><BR><BR><BR><BR>
&nbsp;&nbsp;interface MonoGlyph : Glyph {<BR>
&nbsp;&nbsp;void body(Glyph*);<BR>
&nbsp;&nbsp;Glyph* body() const;<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 2.7: MonoGlyph protocol
<BR>
<A NAME="PAGE22"></A>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>2.10 Example<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
See iv/src/examples/circle.<BR><BR><BR><BR><BR>
&nbsp;&nbsp;2- 9
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
interface Patch : MonoGlyph {<BR>
&nbsp;&nbsp;Patch(Glyph*);<BR>
&nbsp;&nbsp;Canvas* canvas() const;<BR>
&nbsp;&nbsp;const Allocation& allocation() const;<BR>
&nbsp;&nbsp;void reallocate();<BR>
&nbsp;&nbsp;void redraw() const;<BR>
&nbsp;&nbsp;boolean repick(int depth, Hit&);<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 2.8: Patch protocol
<BR>
<A NAME="PAGE23"></A>
</FONT>
<FONT SIZE=9>
<!-- /Times-Bold -->
<B>Chapter 3<BR>
Event processing<BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
This chapter describes the InterViews mechanisms for processing user input. An<BR>
<!-- /Times-Italic -->
<I>event </I><!-- /Times-Roman -->
is an object that represents a user input action, such as pressing a mouse<BR>
button or a keystroke. Events are low-level objects that application code should<BR>
rarely need to access directly. A <!-- /Times-Italic -->
<I>handler </I><!-- /Times-Roman -->
is an object that processes events. An<BR>
<!-- /Times-Italic -->
<I>input handler </I><!-- /Times-Roman -->
is a glyph that provides a handler that translates events to operations<BR>
such as press, release, and keystroke.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>3.1 Events<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
The event class interface is shown in Figure 3.1. Input events arrive in a single<BR>
stream (per display) to an application. EventType is the kind of event (mouse<BR>
motion, button down, etc.). An application receives all window system events,<BR>
but Event::type is only defined for device input. Other events have the type<BR>
Event::other_event. EventButton is the number of a button on a pointing device,<BR>
where Event::any refers to any one of the buttons.<BR>
&nbsp;&nbsp;Event::window returns the window that received the event. Event::pending<BR>
tests if more events are waiting to be read. Event::unread puts the event at the<BR>
front of the input queue for the display.<BR><BR><BR><BR><BR>
&nbsp;&nbsp;3- 1
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
typedef unsigned int EventType;<BR>
&nbsp;&nbsp;typedef unsigned long EventTime;<BR>
&nbsp;&nbsp;typedef unsigned int EventButton;<BR>
&nbsp;&nbsp;typedef unsigned int EventModifierKey;<BR>
&nbsp;&nbsp;interface Event {<BR>
&nbsp;&nbsp;enum { undefined, motion, down, up, key, other_event };<BR>
&nbsp;&nbsp;enum { none, any, left, middle, right, other_button };<BR>
&nbsp;&nbsp;enum { control, shift, capslock, meta };<BR>
&nbsp;&nbsp;Window* window() const;<BR>
&nbsp;&nbsp;boolean pending();<BR>
&nbsp;&nbsp;void unread();<BR>
&nbsp;&nbsp;EventType type() const;<BR>
&nbsp;&nbsp;EventTime time() const;<BR>
&nbsp;&nbsp;Coord pointer_x() const, pointer_y() const;<BR>
&nbsp;&nbsp;EventButton pointer_button() const;<BR>
&nbsp;&nbsp;boolean button_is_down(EventButton) const;<BR>
&nbsp;&nbsp;boolean modifier_is_down(EventModifierKey) const;<BR>
&nbsp;&nbsp;unsigned char keycode() const;<BR>
&nbsp;&nbsp;unsigned int mapkey(char*, unsigned int len) const;<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 3.1: Event protocol
<BR>
<A NAME="PAGE24"></A>
&nbsp;&nbsp;</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Event::time returns a timestamp in milliseconds for the event. Event::pointer_x<BR>
and Event::pointer_y return the pointer location for the event in coordinates<BR>
relative to the lower-left corner of the window. Pointer locations are defined<BR>
for motion, button, and keyboard events. Event::pointer_button returns the<BR>
EventButton for a down or up event, Event::none for all other events.<BR>
Event::button_is_down (Event::modifier_is_down) returns whether the given<BR>
button (modifier key) was down <!-- /Times-Italic -->
<I>before </I><!-- /Times-Roman -->
the event occurred.<BR>
&nbsp;&nbsp;Event::keycode returns the code associated with a keystroke. Key codes are<BR>
potentially platform-specific and should be avoided if possible. Event::mapkey<BR>
finds the string binding for a given key. Event::mapkey is passed a buffer for<BR>
the result and the size of the buffer; it returns the number of characters in the<BR>
translated string. If the event is not a key event, Event::mapkey returns -1.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>3.2 Handlers<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
A handler is an object that is passed an event to process. The only operation<BR>
is Handler::event, which translates a raw event into an abstract operation.<BR>
InputHandler is a monoglygph subclass that uses a handler to translate events.<BR>
ActiveHandler is a subclass of input handler that detects when the input pointer<BR>
enters or leaves its body. Figure 3.2 shows the handler, input handler, and active<BR>
handler protocols.<BR>
&nbsp;&nbsp;The InputHandler constructor is passed the glyph body (which can also<BR>
be set with MonoGlyph::body) and a style. Though a glyph can in general<BR>
have multiple parents, input handlers form a hierarchy for focus management.<BR>
InputHandler::append_focusable adds a child, setting the child's parent to<BR>
the target input handler. InputHandler::remove_focusable removes a child.<BR>
InputHandler::focus sets the current focus for the input handler. The effect of<BR>
setting focus is that key events (or in general any focusable event) will be<BR>
processed by the focus input handler as opposed to an input handler under the<BR>
input pointer coordinates.<BR>
&nbsp;&nbsp;InputHandler::next_focus and InputHandler::prev_focus move the focus<BR>
forward and backward through the children of an input handler.<BR>
InputHandler::focus_in moves the focus #downº the hierarchy and returns the<BR>
handler that now has focus. InputHandler::focus_out notifies an input handler<BR>
that it no longer will receive focusable events, in case it wishes to change its<BR>
appearance.<BR>
&nbsp;&nbsp;InputHandler::move, press, drag, release, and keystroke are called by the<BR>
handler in response to motion, button down, motion while a button is down,<BR>
button up, and key events. InputHandler::double_click is called when two<BR>
button down events occurs within a threshold time. The threshold is set by the<BR>
#clickDelayº style attribute; the default is 250 milliseconds.<BR>
&nbsp;&nbsp;InputHandler::allocation_changed is a notification that the glyph's size or<BR>
position has changed; subclasses can override this operation and therefore<BR><BR>
&nbsp;&nbsp;3- 
<BR>
<A NAME="PAGE25"></A>
typically do not need to define an allocate operation. InputHandler::redraw<BR>
damages the canvas and area where the input handler was most recently drawn.<BR>
&nbsp;&nbsp;The implementation of ActiveHandler notices when motion events first<BR>
intersect the glyph's body, in which case ActiveHandler::enter is called, and when<BR>
the motion next leaves the body, in which case ActiveHandler::leave is called.<BR>
The default enter and leave operations do nothing; subclasses should define these<BR>
operations as desired.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>3.3 Targets<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
A <!-- /Times-Italic -->
<I>target </I><!-- /Times-Roman -->
controls the behavior of picking on its body. A target is useful for<BR>
defining a pick area that is not identical to the underlying object. For example, if<BR>
one wanted to pick in a line of characters then one might wish to interpret the pick<BR>
based on the line height instead of the heights of the individual characters. So, a<BR>
&nbsp;&nbsp;3- 3
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
interface Handler : Resource {<BR>
&nbsp;&nbsp;boolean event(Event&) ;<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;interface InputHandler : MonoGlyph {<BR>
&nbsp;&nbsp;InputHandler(Glyph*, Style*);<BR>
&nbsp;&nbsp;Handler* handler() const;<BR>
&nbsp;&nbsp;InputHandler* parent() const;<BR>
&nbsp;&nbsp;Style* style() const;<BR>
&nbsp;&nbsp;void append_input_handler(InputHandler*);<BR>
&nbsp;&nbsp;void remove_input_handler(InputHandler*);<BR>
&nbsp;&nbsp;void focus(InputHandler*);<BR>
&nbsp;&nbsp;void next_focus();<BR>
&nbsp;&nbsp;void prev_focus();<BR>
&nbsp;&nbsp;InputHandler* focus_in();<BR>
&nbsp;&nbsp;void focus_out();<BR>
&nbsp;&nbsp;void move(const Event&);<BR>
&nbsp;&nbsp;void press(const Event&);<BR>
&nbsp;&nbsp;void drag(const Event&);<BR>
&nbsp;&nbsp;void release(const Event&);<BR>
&nbsp;&nbsp;void keystroke(const Event&);<BR>
&nbsp;&nbsp;void double_click(const Event&);<BR>
&nbsp;&nbsp;void allocation_changed(Canvas*, const Allocation&);<BR>
&nbsp;&nbsp;void redraw() const;<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;interface ActiveHandler : InputHandler {<BR>
&nbsp;&nbsp;ActiveHandler(Glyph*, Style*);<BR>
&nbsp;&nbsp;void enter();<BR>
&nbsp;&nbsp;void leave();<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 3.2: Handler and InputHandler protocols
<BR>
<A NAME="PAGE26"></A>
</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
pick lower than the top of the ``h'' in ``the'' but above the ``e'' will not miss.<BR>
&nbsp;&nbsp;Figure 3.3 shows the target class interface. The target behavior is controlled by<BR>
the sensitivity parameter to the constructor. TargetPrimitiveHit means the body is<BR>
hit if the pick region intersects the target's allocation. TargetCharacterHit means<BR>
the body is hit if the area intersects the target's allocation in the X dimension.<BR><BR><BR><BR><BR>
&nbsp;&nbsp;3- 4
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
enum TargetSensitivity {<BR>
&nbsp;&nbsp;TargetPrimitiveHit,<BR>
&nbsp;&nbsp;TargetCharacterHit<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;interface Target : MonoGlyph {<BR>
&nbsp;&nbsp;Target(Glyph* body, TargetSensitivity);<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 3.3: Target class interface
<BR>
<A NAME="PAGE27"></A>
</FONT>
<FONT SIZE=9>
<!-- /Times-Bold -->
<B>Chapter 4<BR>
Views<BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
This chapter describes the mechanisms for supporting multiple views of data.<BR>
Currently, this support consists of three protocols: <!-- /Times-Italic -->
<I>observable, observer, </I><!-- /Times-Roman -->
and<BR>
<!-- /Times-Italic -->
<I>adjustable. </I><!-- /Times-Roman -->
An observable object is one that has one or more observers that it can<BR>
notify (typically when it changes). An adjustable object uses an observable for<BR>
each dimension to keep track of observers that can scroll or zoom the visible areas<BR>
of the object.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>4.1 Observable and Observer<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Figure 4.1 shows the observable and observer protocols. An observer can be<BR>
attached or detached to an observable. Observable::notify calls Observer::update<BR>
on each of the attached observers. When an observable object is destroyed, it will<BR>
call Observer::disconnect on any attached observers.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>4.2 Adjustable<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
An adjustable is an object that handles requests to modify its viewing area. For<BR>
example, a scrollable list is adjustable in that a scrollbar or other object can<BR>
request that a particular subrange of items in the list be shown.<BR>
&nbsp;&nbsp;Figure 4.2 shows the adjustable protocol. Adjustable::attach and<BR>
Adjustable::detach add an observer to the list of objects notified when a particular<BR>
dimension changes. Adjustable::notify calls update on those observers attached to<BR>
the given dimension. Adjustable::notify_all is equivalent to calling notify on<BR>
every dimension.<BR><BR><BR><BR><BR>
&nbsp;&nbsp;4- 1
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
interface Observable {<BR>
&nbsp;&nbsp;void attach(Observer*);<BR>
&nbsp;&nbsp;void detach(Observer*);<BR>
&nbsp;&nbsp;void notify();<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;interface Observer {<BR>
&nbsp;&nbsp;void update(Observable*);<BR>
&nbsp;&nbsp;void disconnect(Observable*);<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 4.1: Observable and observer protocols
<BR>
<A NAME="PAGE28"></A>
&nbsp;&nbsp;</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Adjustable::lower and Adjustable::upper define a coordinate range for<BR>
adjustment in a specific dimension. Adjustable::length is equivalent<BR>
to Adjustable::upper minus Adjustable::lower. Adjustable::cur_lower and<BR>
Adjustable::cur_upper define the region within a coordinate range that is currently<BR>
in view. Adjustable::cur_length is equivalent to Adjustable::cur_upper minus<BR>
Adjustable::cur_lower.<BR>
&nbsp;&nbsp;Adjustable::scroll_forward and Adjustable::scroll_backward add a small fixed<BR>
amount to Adjustable::cur_lower (where the amount is determined by the<BR>
adjustable object). Adjustable::page_forward and Adjustable::page_backward<BR>
add a larger fixed amount. Adjustable::scroll_to sets the adjustable's current<BR>
lower coordinate to a specific value. Adjustable::scale_to sets the current length<BR>
to a given fraction of the total length. Adjustable::zoom_to sets the scale in<BR>
all dimensions at once. Adjustable::constrain restricts a value to be within the<BR>
adjustable's lower and upper bounds.<BR>
&nbsp;&nbsp;<!-- /Times-Italic -->
<I>Example: see iv/src/examples/bvalue/main.c.<BR><BR>
</I></FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>4.3 View<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Italic -->
<I>This section will be completed in the future.<BR><BR><BR>
&nbsp;&nbsp;</I><!-- /Times-Roman -->
4- 2
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
interface Adjustable {<BR>
&nbsp;&nbsp;Observable* observable(DimensionName) const;<BR>
&nbsp;&nbsp;void attach(DimensionName, Observer*);<BR>
&nbsp;&nbsp;void detach(DimensionName, Observer*);<BR>
&nbsp;&nbsp;void notify(DimensionName) const;<BR>
&nbsp;&nbsp;void notify_all() const;<BR>
&nbsp;&nbsp;Coord lower(DimensionName) const;<BR>
&nbsp;&nbsp;Coord upper(DimensionName) const;<BR>
&nbsp;&nbsp;Coord length(DimensionName) const;<BR>
&nbsp;&nbsp;Coord cur_lower(DImensionName) const;<BR>
&nbsp;&nbsp;Coord cur_upper(DimensionName) const;<BR>
&nbsp;&nbsp;Coord cur_length(DimensionName) const;<BR>
&nbsp;&nbsp;void scroll_forward(DimensionName);<BR>
&nbsp;&nbsp;void scroll_backward(DimensionName);<BR>
&nbsp;&nbsp;void page_forward(DimensionName);<BR>
&nbsp;&nbsp;void page_backwards(DimensionName);<BR>
&nbsp;&nbsp;void scroll_to(DImensionName, Coord lower);<BR>
&nbsp;&nbsp;void scale_to(DimensionName, float fraction);<BR>
&nbsp;&nbsp;void zoom_to(float magnification);<BR>
&nbsp;&nbsp;void constrain(DimensionName, Coord&) const;<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 4.2: Adjustable protocol
<BR>
<A NAME="PAGE29"></A>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>4.4 Data<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Italic -->
<I>This section will be completed in the future.<BR><BR>
</I></FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>4.5 Inset<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Italic -->
<I>This section will be completed in the future.<BR><BR><BR><BR><BR>
&nbsp;&nbsp;</I><!-- /Times-Roman -->
4- 
<BR>
<A NAME="PAGE30"></A>
</FONT>
<FONT SIZE=9>
<!-- /Times-Bold -->
<B>Chapter 5<BR>
Windows<BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
The previous chapters covered the composition of physical (glyphs) and logical<BR>
(views) objects. This chapter discusses the other objects necessary to manage<BR>
where glyphs are drawn. A <!-- /Times-Italic -->
<I>window </I><!-- /Times-Roman -->
is an object that can be mapped onto a <!-- /Times-Italic -->
<I>screen<BR>
</I><!-- /Times-Roman -->
and receive input. Associated with a window is the root of a directed acyclic graph<BR>
of glyphs. The window creates a <!-- /Times-Italic -->
<I>canvas </I><!-- /Times-Roman -->
that is bound to a portion of the screen<BR>
when the window is mapped. The window calls Glyph::draw on the root glyph to<BR>
refresh the canvas and Glyph::pick to determine what to do with input events<BR>
&nbsp;&nbsp;Figure 5.1 shows the Window base class interface. Window::style sets or<BR>
gets the style associated with the window. Several style attributes control<BR>
characteristics of a window: #double_bufferedº controls whether the window is<BR>
double-buffered by default, #visualº specifies the name of a visual to use for the<BR>
window, #visual_idº specifies the id of the desired visual, and #overlayº specifies<BR>
whether overlay planes should be used for the window.<BR><BR><BR><BR><BR>
&nbsp;&nbsp;5- 1
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
interface Window {<BR>
&nbsp;&nbsp;Window(Glyph* = nil);<BR>
&nbsp;&nbsp;void style(Style*);<BR>
&nbsp;&nbsp;Style* style() const;<BR>
&nbsp;&nbsp;void display(Display*);<BR>
&nbsp;&nbsp;Display* display() const;<BR>
&nbsp;&nbsp;Canvas* canvas() const;<BR>
&nbsp;&nbsp;void cursor(Cursor*);<BR>
&nbsp;&nbsp;Cursor* cursor() const;<BR>
&nbsp;&nbsp;void push_cursor();<BR>
&nbsp;&nbsp;void pop_cursor();<BR>
&nbsp;&nbsp;void place(Coord left, Coord bottom);<BR>
&nbsp;&nbsp;void align(float x, float y);<BR>
&nbsp;&nbsp;Coord left() const, bottom() const, width() const, height() const;<BR>
&nbsp;&nbsp;void map(), unmap();<BR>
&nbsp;&nbsp;boolean is_mapped() const;<BR>
&nbsp;&nbsp;void raise(), lower();<BR>
&nbsp;&nbsp;void move(Coord left, Coord bottom);<BR>
&nbsp;&nbsp;void resize();<BR>
&nbsp;&nbsp;void receive(const Event&);<BR>
&nbsp;&nbsp;void grab_pointer(Cursor* = nil) const;<BR>
&nbsp;&nbsp;void ungrab_pointer() const;<BR>
&nbsp;&nbsp;void repair();<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 5.1: Window protocol
<BR>
<A NAME="PAGE31"></A>
&nbsp;&nbsp;</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Window::display sets or gets the display that a window is mapped on (or nil if<BR>
the window is not currently mapped). Window::canvas returns the canvas that the<BR>
window passes to its glyph for drawing.<BR>
&nbsp;&nbsp;Window::cursor sets or gets the image that tracks a pointing device's position<BR>
when the it is inside the window. Cursors are defined by two bitmaps and<BR>
a ``hot spot''. The mask bitmap specifies which pixels are to be drawn,<BR>
and the pattern bitmap specifies which pixels are in foreground color and<BR>
which are in background color. The hot spot specifies the location of the<BR>
pointing device relative to the cursor's lower-left corner. The foreground and<BR>
background colors for a cursor are defined by the attributes #pointerColorº and<BR>
#pointerColorBackgroundº in the window's style.<BR>
&nbsp;&nbsp;Figure 5.2 shows the cursor protocol. A cursor can be created from specific<BR>
data, pattern and mask bitmaps, a character in a font, or an index into the standard<BR>
cursor information for the target window system. If the cursor is specified with<BR>
bitmaps, the hot spot is the origin of the pattern bitmap; if specified with a<BR>
character, it is the origin of the character's bitmap in the font. An index implies<BR>
both bitmaps as well as the hot spot. Specific values for the index are usually<BR>
defined in an include file. For example, standard X11 cursors are defined in the<BR>
file <X11/cursorfont.h>.<BR>
&nbsp;&nbsp;Window::place specifies the desired screen coordinates for a window.<BR>
Window::align specifies a desired alignment. The alignment values are fractions<BR>
that indicate where the window should appear relative to its coordinates as<BR>
specified by a call to Window::place. For example, an alignment of 0.0,1.0 means<BR>
the placement specifies the upper-left corner of the window. An alignment of<BR>
0.5,0.5 means the placement specifies the center of the window. Unless specified,<BR>
the alignment will be 0.0,0.0, meaning the placement coordinates specify the<BR>
lower-left corner of the window.<BR>
&nbsp;&nbsp;Window::map requests the window to be mapped onto the screen. If no display<BR>
has been set, then the session's default display is used. Window::map may be<BR>
asynchronous±one cannot assume the window is usable immediately after calling<BR>
map. Window::unmap requests that the window be removed from the screen.<BR>
&nbsp;&nbsp;Window::raise and Window::lower control the stacking order of a window on<BR>
the screen. Window::raise makes the window above all the other windows on the<BR>
screen; Window::lower make the window below all the others. These operations<BR>
usually are neither necessary nor appropriate, as stacking order should normally<BR><BR><BR><BR><BR>
&nbsp;&nbsp;5- 2
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
interface Cursor {<BR>
&nbsp;&nbsp;Cursor(short x, short y, const int* pattern, const int* mask);<BR>
&nbsp;&nbsp;Cursor(const Bitmap* pat, const Bitmap* mask);<BR>
&nbsp;&nbsp;Cursor(const Font*, int pattern, int mask);<BR>
&nbsp;&nbsp;Cursor(int index);<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 5.2: Cursor class interface
<BR>
<A NAME="PAGE32"></A>
</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
be under control of the user through a window manager.<BR>
&nbsp;&nbsp;The window systems delivers input events to a particular window, which in turn<BR>
tries to find a handler to process each event. Window::receive examines an event,<BR>
handling window maintenance events internally. For example, X expose and<BR>
configure events are handled directly by Window::receive.<BR>
&nbsp;&nbsp;Window::grab_pointer takes control of pointer input events for the display.<BR>
Other applications will not receive pointer events until Window::ungrab_pointer<BR>
is called to release control. If a cursor is passed to Window::grab_pointer, it will<BR>
be used when the pointer is outside the window during the grab.<BR>
&nbsp;&nbsp;If any part of a window's canvas has been damaged, Window::repair will<BR>
call draw on the root glyph and perform the necessary screen update when<BR>
double-buffering. All windows on a display will be repaired automatically<BR>
before blocking for input from the display, so applications usually need not call<BR>
Window::repair directly.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>5.1 ManagedWindow<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
A managed window specifies information for a window manager to use.<BR>
ManagedWindow is an abstract base class with four predefined descendants:<BR>
ApplicationWindow, TopLevelWindow, TransientWindow, and IconWindow.<BR>
An application should create one application window, which makes information<BR>
about command-line arguments available to a session manager, if present on the<BR>
system. After the application window, normal windows are top-level. A top-level<BR>
window can have a ``group leader'', which is typically the application window. A<BR>
window manager may allow quick control of all windows with the same group<BR>
leader, such as when iconifying or deiconifying.<BR>
&nbsp;&nbsp;A transient window is often treated specially by window managers. It may be<BR>
decorated differently (or not at all), or automatically unmapped when the main<BR>
window is iconified. Transient windows are used for temporary controls, such as<BR>
dialog boxes, but not for unmanaged windows such as popups or pulldowns. A<BR>
transient is usually associated with another managed window.<BR>
&nbsp;&nbsp;An icon window is a window that is mapped when its associated window<BR>
is iconified and unmapped when its associated window is deiconified. Calling<BR>
Window::map on an icon window will therefore bind it to the window system, but<BR>
will not map it on the screen.<BR>
&nbsp;&nbsp;Figure 5.3 shows the ManagedWindow protocol. Most of the operations on<BR>
a managed window set or return information associated with the window. In<BR>
addition, ManagedWindow interprets additional attributes in its style inherited<BR>
from the base class. The attribute #nameº specifies a string name for the<BR>
window manager to use, #iconNameº specifies a string for the window's icon,<BR>
#geometryº specifies the desired geometry, and #iconGeometryº specifies the<BR>
desired geometry for the window's icon. Geometry specifications are strings of<BR>
the form ``WxH+X+Y'' where W is the width, H the height, X the left corner, and<BR><BR>
&nbsp;&nbsp;5- 
<BR>
<A NAME="PAGE33"></A>
Y the top corner of the window. Either the position or the size may be omitted,<BR>
and the position can use ``±'' instead of ``+'' to denote distance from the opposite<BR>
of the display to the opposite side of the window. For example, a ±X value<BR>
specifies that the right side of the window should be a distance of X from the right<BR>
edge of the screen.<BR>
&nbsp;&nbsp;ManagedWindow::icon_bitmap and ManagedWindow::icon_mask specify two<BR>
bitmaps to use to draw an icon. The mask defines the area to be drawn and the<BR>
bitmap defines the foreground and background areas. Pixels that correspond to a<BR>
one in the bitmap and a one in the mask are drawn with the foreground color.<BR>
Pixels that correspond to a zero in the bitmap and a one in the mask are draw with<BR>
the background color. Pixels that correspond to a zero in the mask are not drawn.<BR>
&nbsp;&nbsp;ManagedWindow::icon specifies a second window to map when the first<BR>
window is iconified. Using a window as an icon overrides the other icon<BR>
information. Therefore, it does not make sense to use ManagedWindow::icon<BR>
in conjunction with icon_bitmap, icon_mask, or the #iconNameº and<BR>
#iconGeometryº attributes.<BR>
&nbsp;&nbsp;ManagedWindow::iconic specifies the initial state of a window. If iconic is true,<BR>
mapping a window will actually map its icon instead. ManagedWindow::iconic<BR>
need not be called directly by an application; it is called automatically if specified<BR>
by user customization information.<BR>
&nbsp;&nbsp;ManagedWindow::iconify requests the window be unmapped and the window's<BR>
icon be mapped to the screen. ManagedWindow::deiconify reverses the operation,<BR>
unmapping the icon and mapping the original window. It does not make sense to<BR>
iconify or deiconify an icon window.<BR>
&nbsp;&nbsp;ManagedWindow::focus_event specifies handlers for the window receiving and<BR>
losing keyboard focus from the window manager. ManagedWindow::wm_delete<BR>
specifies a handler for a request from the window manager to delete the window.<BR>
&nbsp;&nbsp;5- 4
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
interface ManagedWindow : Window {<BR>
&nbsp;&nbsp;void icon_bitmap(Bitmap*);<BR>
&nbsp;&nbsp;Bitmap* icon_bitmap() const;<BR>
&nbsp;&nbsp;void icon_mask(Bitmap*);<BR>
&nbsp;&nbsp;Bitmap* icon_mask() const;<BR>
&nbsp;&nbsp;void icon(ManagedWindow*);<BR>
&nbsp;&nbsp;ManagedWindow* icon() const;<BR>
&nbsp;&nbsp;void iconic(boolean);<BR>
&nbsp;&nbsp;boolean iconic() const;<BR>
&nbsp;&nbsp;void iconify();<BR>
&nbsp;&nbsp;void deiconify();<BR>
&nbsp;&nbsp;void focus_event(Handler* in, Handler* out);<BR>
&nbsp;&nbsp;void wm_delete(Handler*);<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 5.3: ManagedWindow class interface
<BR>
<A NAME="PAGE34"></A>
</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
If the handler is nil (which is the initial value), then the response to this event will<BR>
be to call Session::quit.<BR>
&nbsp;&nbsp;Figure 5.4 shows the operations on the ManagedWindow subclasses.<BR>
ApplicationWindow and IconWindow provide no additional operations beyond a<BR>
constructor. TopLevelWindow provides an operation to set or return its group<BR>
leader. TransientWindow is a subclass to TopLevelWindow that can additionally<BR>
be associated with a primary window with TransientWindow::transient_for.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>5.2 PopupWindow<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
A popup window is mapped directly to a screen without window manager<BR>
interaction (or knowledge). In the X Window System, a popup window will<BR>
override the normal redirection of map requests to window managers. Popups on<BR>
X also will request that the pixels under the popup be saved to avoid a subsequent<BR>
exposure when the popup is unmapped.<BR>
&nbsp;&nbsp;Popups should only be used for temporary windows, such as popup or pulldown<BR>
menus. Because they do not go through the window manager, popups should be<BR>
placed explicitly. Here is an example of using a popup that appears below a<BR>
menubar, aligning the top of the popup to the lower left corner of the menubar:<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
void pulldown(Window* menubar, Glyph* g) {<BR>
&nbsp;&nbsp;PopupWindow* popup = new PopupWindow(g);<BR>
&nbsp;&nbsp;popup->place(menubar->left(), menubar()->bottom());<BR>
&nbsp;&nbsp;popup->align(0.0, 1.0);<BR>
&nbsp;&nbsp;popup->map();<BR><BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
5- 5
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
interface ApplicationWindow : ManagedWindow {<BR>
&nbsp;&nbsp;ApplicationWindow(Glyph*);<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;interface TopLevelWindow : ManagedWindow {<BR>
&nbsp;&nbsp;TopLevelWindow(Glyph*);<BR>
&nbsp;&nbsp;void group_leader(ManagedWindow*);<BR>
&nbsp;&nbsp;ManagedWindow* group_leader() const;<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;interface TransientWindow : TopLevelWindow {<BR>
&nbsp;&nbsp;TransientWindow(Glyph*);<BR>
&nbsp;&nbsp;void transient_for(ManagedWindow*);<BR>
&nbsp;&nbsp;void ManagedWindow* transient_for() const;<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;interface IconWindow : ManagedWindow {<BR>
&nbsp;&nbsp;IconWindow(Glyph*);<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 5.4: ManagedWindow subclasses
<BR>
<A NAME="PAGE35"></A>
&nbsp;&nbsp;}<BR><BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>5.3 Display<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
A <!-- /Times-Italic -->
<I>display </I><!-- /Times-Roman -->
is the unit of window system control; typically it consists of a single<BR>
screen, keyboard, and a mouse or other pointing device. Application objects<BR>
typically need not deal directly with a display; the functionality of the window<BR>
class is normally sufficient.<BR>
&nbsp;&nbsp;Figure 5.5 shows the display class interface. Display::open is a static member<BR>
function that opens a connection to the display with the given name. The<BR>
interpretation of a display name is system-dependent. On X, the name is<BR>
<!-- /Times-Italic -->
<I>host:number </I><!-- /Times-Roman -->
where <!-- /Times-Italic -->
<I>host </I><!-- /Times-Roman -->
is a machine's hostname and <!-- /Times-Italic -->
<I>number </I><!-- /Times-Roman -->
is the index for the<BR>
display connected to that host (typically 0). If successful, Display::open returns<BR>
a pointer to a display object. If not successful, it returns nil. Display::close<BR>
terminates the connection.<BR>
&nbsp;&nbsp;Display::width and Display::height return the dimensions in coordinates of<BR>
the display's current screen. Display::a_width and Display::a_height return the<BR>
dimensions in points (72 points =
&nbsp;&nbsp; 
&nbsp;&nbsp; one inch).<BR><BR><BR><BR><BR>
&nbsp;&nbsp;5- 6
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
interface Display {<BR>
&nbsp;&nbsp;static Display* open(const String&);<BR>
&nbsp;&nbsp;static Display* open();<BR>
&nbsp;&nbsp;virtual void close();<BR>
&nbsp;&nbsp;virtual Coord width() const;<BR>
&nbsp;&nbsp;virtual Coord height() const;<BR>
&nbsp;&nbsp;virtual Coord a_width() const;<BR>
&nbsp;&nbsp;virtual Coord a_height() const;<BR>
&nbsp;&nbsp;int to_pixels(Coord) const;<BR>
&nbsp;&nbsp;Coord to_coord(int) const;<BR>
&nbsp;&nbsp;virtual void set_screen(int);<BR>
&nbsp;&nbsp;virtual void style(Style*);<BR>
&nbsp;&nbsp;virtual Style* style() const;<BR>
&nbsp;&nbsp;virtual void repair();<BR>
&nbsp;&nbsp;virtual void flush();<BR>
&nbsp;&nbsp;virtual void sync()<BR>
&nbsp;&nbsp;virtual void ring_bell(int);<BR>
&nbsp;&nbsp;virtual void set_key_click(int);<BR>
&nbsp;&nbsp;virtual void set_auto_repeat(boolean);<BR>
&nbsp;&nbsp;virtual void set_pointer_feedback(int thresh, int scale);<BR>
&nbsp;&nbsp;virtual void move_pointer(Coord x, Coord y);<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 5.5: Display class interface.
<BR>
<A NAME="PAGE36"></A>
&nbsp;&nbsp;</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Display::to_pixels and Display::to_coord convert between coordinates and<BR>
pixels. The conversion is a function of the <!-- /Times-Italic -->
<I>dpi </I><!-- /Times-Roman -->
attribute, which is 75 by default.<BR>
One coordinate unit length is a printer's point, defined as 72/dpi pixels.<BR>
&nbsp;&nbsp;Display::set_screen sets the current screen to use for display operations.<BR>
Initially, current screen is set to 0.<BR>
&nbsp;&nbsp;Display::repair calls Window::repair for each window on the display that has<BR>
a canvas with damage. It is not necessary to call Display::repair directly, as<BR>
windows will automatically be repaired before blocking for input events.<BR>
&nbsp;&nbsp;Display::flush and Display::sync are used to synchronize with the window<BR>
system. Display::flush repairs all damaged windows on the display and ensures<BR>
that any pending requests have been sent to the window system. Display::sync is<BR>
the same as Display::flush, but additionally waits for an acknowledgement from<BR>
the window system.<BR>
&nbsp;&nbsp;Display::ring_bell sounds the workstation's bell at a specified volume. The<BR>
parameter should be between 0 and 100, where 0 is silent and 100 is the loudest<BR>
possible bell.<BR>
&nbsp;&nbsp;The operations set_key_click, set_auto_repeat, and set_pointer_feedback<BR>
modify the key click volume, the flag determining whether keys should repeat,<BR>
and the pointer interpretation parameters, respectively. Display::move_pointer<BR>
changes the position of the input pointer. This operation can have surprising<BR>
effects to the user and should generally be avoided.<BR><BR><BR><BR><BR>
&nbsp;&nbsp;5- 
<BR>
<A NAME="PAGE37"></A>
</FONT>
<FONT SIZE=9>
<!-- /Times-Bold -->
<B>Chapter 6<BR>
Rendering<BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
This chapter describes the InterViews classes for drawing on the screen and on a<BR>
printer. The two primary classes are Canvas, which represents an area on the<BR>
screen, and Printer, which sends output suitable for printing to an output stream.<BR>
The drawing classes are intended to be simple and resolution-independent. The<BR>
programming interface resembles the PostScript drawing operations.<BR>
&nbsp;&nbsp;Printer is a subclass of Canvas, and as such implements the same drawing<BR>
operations as Canvas. However, it is possible that glyphs may use other rendering<BR>
operations than those provided by Canvas, such as for 3D. In this case, glyphs<BR>
should provide distinct draw and print operations. If a glyph does not need<BR>
operations other than those provided by Canvas then the glyph can rely on default<BR>
implementation of drawing on a printer, which just calls the canvas-directed draw<BR>
with the printer as the target.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>6.1 Graphics Attributes<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
InterViews provides classes that represent graphics attributes such as colors<BR>
and fonts. The instances are all sharable, meaning the classes are derived<BR>
from Resource. The objects are also display-independent, meaning they will<BR>
correspond to several underlying objects in applications that run on multiple<BR>
displays. For example, a single InterViews color object might have different pixel<BR>
values on different displays.<BR>
</FONT>
<FONT SIZE=4>
<!-- /Times-Bold -->
<B>6.1.1 Brush<BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
A brush defines the line thickness and line style for drawing operations. The<BR>
effect of these operations is as if a line segment equal in length to the<BR>
brush's width were dragged along an infinitely thin path between the specified<BR>
coordinates. At each point along the path the brush is angled perpendicular to the<BR>
path. As a special case, a brush width of zero specifies a minimal-width line.<BR>
Many devices can render minimal-width lines more quickly than wide lines, but<BR>
the resulting display may vary slightly across devices. A solid brush style paints<BR>
all pixels along the path with a single color. A dashed brush defines alternating<BR>
foreground and background segments, measured along the length of the path.<BR>
Foreground segments are painted, while background segments are not.<BR>
&nbsp;&nbsp;Figure 6.1 shows the Brush class interface. The first constructor creates a solid<BR>
brush of the given width. The second constructor creates a brush with the given<BR>
width and line style. The pattern is an array of integers that specifies the length of<BR>
successive foreground and background segments. Even-numbered array indices<BR>
(starting from 0) specify the length of foreground segments; odd-numbered<BR>
&nbsp;&nbsp;6- 
<BR>
<A NAME="PAGE38"></A>
indices specify background segments. The </FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
count </FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
is the number of entries in the<BR>
array. The count can be zero, which specifies a solid brush. The last constructor<BR>
defines a brush with a given width and a style specified by a bit vector. The<BR>
least significant 16 bits of </FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
pattern </FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
are interpreted as a bit pattern, with one bits<BR>
specifying foreground segments and zero bits specifying background segments.<BR>
</FONT>
<FONT SIZE=4>
<!-- /Times-Bold -->
<B>6.1.2 Color<BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
A color object defines an output color, which is specified by a mix of RGB (red,<BR>
green, and blue) intensities, and an alpha value for blending. Figure 6.2 shows the<BR>
Color class interface. RGB and alpha values are represented as floating point<BR>
numbers between 0 and 1, where 1 is full intensity (or visibility in the case of<BR>
alpha). A color object is created with the RGB intensities, an alpha value (default<BR>
is 1.0), and a drawing operation. A color drawing operation need be specified<BR>
only on rare occasions. The default operation, Copy, blends the color in directly.<BR>
The Xor operation uses a pixel value computed by taking the exclusive-or of the<BR>
color and the existing pixel value. Xor is only useful on a monochrome system.<BR>
&nbsp;&nbsp;Color::lookup returns the color with the given name as defined on the given<BR>
display or nil if the name is not defined. Color::distinguished determines if two<BR>
colors are distinct on a particular display. A common use of Color::distinguished<BR>
is to check if a highlighting color is distinct from foreground and background<BR>
colors. Color::intensities returns the RGB values for a given color on a given<BR>
display. Color::brightness creates a new color that is brighter or darker than<BR>
the given color by a certain adjustment. If the adjust parameter is positive, it<BR>
indicates the new intensity should be the given fraction of the distance between<BR>
the current intensity and full intensity. If the parameter is negative, its absolute<BR>
value specifies a distance to zero intensity.<BR>
&nbsp;&nbsp;InterViews automatically translates an RGB specification to the appropriate<BR>
pixel value for a window. This approach hides the system-dependent details of<BR>
color management from applications, making them more portable and giving<BR>
greater flexibility to graphics system implementors. Under the X Window System,<BR>
color-intensive applications might not find the default color implementation<BR>
acceptable. To assist such applications, InterViews provides a way to specify an<BR>
X visual, either on the command-line with the ``-visual'' flag, or with a ``visual''<BR>
X resource defined to the desired visual type. For example, on displays that<BR>
support TrueColor (which means pixel values can be computed directly from<BR>
RGB values) but for which the default visual is not TrueColor, a user could run an<BR>
application with ``-visual TrueColor'' or define ``*app*visual:TrueColor'' in the<BR>
&nbsp;&nbsp;6- 2
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
interface Brush : Resource {<BR>
&nbsp;&nbsp;Brush(Coord width);<BR>
&nbsp;&nbsp;Brush(int* pattern, int count, Coord width);<BR>
&nbsp;&nbsp;Brush(int pattern, Coord width);<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 6.1: Brush class interface
&nbsp;&nbsp;<BR><BR><BR><BR><BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
6- 
<BR>
<A NAME="PAGE39"></A>
application defaults file.<BR>
</FONT>
<FONT SIZE=4>
<!-- /Times-Bold -->
<B>6.1.3 Font<BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
A font defines a mapping between character codes and their appearance on the<BR>
screen. PSFont is a subclass of Font that uses PostScript metrics for character<BR>
widths, if the metrics are available on the system. Figure 6.3 shows the Font and<BR>
PSFont class interfaces. The Font constructor is given the full name of the font<BR>
and a scaling factor. If the font is used on a display that does not recognize the<BR>
name, then a default font will be used. Font::find can be used to compute a valid<BR>
fullname for a font from a given font family name, desired point size, and font<BR>
style (such as italic or bold). If a font is available that matches all but the point<BR>
size, Font::find will return the font with </FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
scale </FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
set to the ratio of the desired point<BR>
size to the actual point size.<BR>
&nbsp;&nbsp;Font::name returns the full name of the font. Font::encoding returns the<BR>
character set identification, such as ``iso8859'' for ISO Latin. Font::size returns<BR>
the point size of the font.<BR>
&nbsp;&nbsp;Font::font_bbox, Font::char_bbox, and Font::string_bbox return information<BR>
about the overall font, a specific character in the font, or a string of characters.<BR>
Each operation returns a FontBoundingBox object, which has operations to return<BR>
detailed information.<BR>
&nbsp;&nbsp;FontBoundingBox::ascent returns the extent above the font's baseline;<BR>
FontBoundingBox::descent returns the extent below the font's baseline.<BR>
FontBoundingBox::left_bearing returns the left edge of the bitmap associated<BR>
with a character; FontBoundingBox::right_bearing returns the right edge.<BR>
&nbsp;&nbsp;Font::width on a single character returns the width of a character's bitmap<BR>
and on a string it returns the sum of the widths of the individual characters.<BR>
&nbsp;&nbsp;6- 3 6- 3
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
typedef float ColorIntensity;<BR>
&nbsp;&nbsp;typedef unsigned int ColorOp;<BR>
&nbsp;&nbsp;interface Color : Resource {<BR>
&nbsp;&nbsp;enum { Copy, Xor };<BR>
&nbsp;&nbsp;Color(<BR>
&nbsp;&nbsp;ColorIntensity r, ColorIntensity g, ColorIntensity b,<BR>
&nbsp;&nbsp;float alpha = 1.0, ColorOp = Copy<BR>
&nbsp;&nbsp;);<BR>
&nbsp;&nbsp;Color(const Color&, float alpha = 1.0, ColorOp = Copy);<BR>
&nbsp;&nbsp;static const Color* lookup(Display*, const String& name);<BR>
&nbsp;&nbsp;static const Color* lookup(Display*, const char*);<BR>
&nbsp;&nbsp;boolean distinguished(Display*, Color*);<BR>
&nbsp;&nbsp;void intensities(<BR>
&nbsp;&nbsp;Display*, ColorIntensity& r, ColorIntensity& g, ColorIntensity& b<BR>
&nbsp;&nbsp;) const;<BR>
&nbsp;&nbsp;const Color* brightness(float adjust) const;<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 6.2: Color class interface
<BR>
<A NAME="PAGE40"></A>
</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Font::index returns the index of the character in a string that would be </FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
offset<BR>
</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
coordinates from the left if the string were displayed. If </FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
between </FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
is false, the<BR>
index of the character that contains </FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
offset </FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
is returned; otherwise the index of the<BR>
character following the between-character space that is nearest </FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
offset </FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
is returned.<BR>
In either case a negative offset will return an index of zero and an offset beyond<BR>
the end of the string will return an index equal to the length of the string.<BR>
</FONT>
<FONT SIZE=4>
<!-- /Times-Bold -->
<B>6.1.4 Transformer<BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
A transformer object represents a 3x2 matrix for use in translating 2D coordinates.<BR>
Figure 6.4 shows the Transformer class interface. The transformer constructor<BR>
with no parameters creates an identity matrix. The other constructor takes the<BR>
explicit matrix values as parameters. Transformer::identity returns whether the<BR>
matrix is currently the identity matrix.<BR><BR>
&nbsp;&nbsp;6- 4 6- 4
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
interface FontBoundingBox {<BR>
&nbsp;&nbsp;Coord left_bearing() const, right_bearing() const;<BR>
&nbsp;&nbsp;Coord width() const, ascent() const, descent() const;<BR>
&nbsp;&nbsp;Coord font_ascent() const, font_descent() const;<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;typedef long FontCharCode;<BR>
&nbsp;&nbsp;interface Font : Resource {<BR>
&nbsp;&nbsp;Font(const String&, float scale = 1.0);<BR>
&nbsp;&nbsp;Font(const char* fullname, float scale = 1.0);<BR>
&nbsp;&nbsp;static boolean find(<BR>
&nbsp;&nbsp;const char* family, int size, const char* style,<BR>
&nbsp;&nbsp;const char*& fullname, float& scale<BR>
&nbsp;&nbsp;);<BR>
&nbsp;&nbsp;static const Font* lookup(const char*);<BR>
&nbsp;&nbsp;static const Font* lookup(const String&);<BR>
&nbsp;&nbsp;const char* name() const;<BR>
&nbsp;&nbsp;const char* encoding() const;<BR>
&nbsp;&nbsp;Coord size();<BR>
&nbsp;&nbsp;void font_bbox(FontBoundingBox&) const;<BR>
&nbsp;&nbsp;void char_bbox(FontCharCode, FontBoundingBox&) const;<BR>
&nbsp;&nbsp;void stringt_bbox(const char*, int, FontBoundingBox&);<BR>
&nbsp;&nbsp;virtual Coord width(FontCharCode);<BR>
&nbsp;&nbsp;virtual Coord width(const char*, int);<BR>
&nbsp;&nbsp;virtual int index(const char*, int, float offset, boolean between);<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;interface PSFont : Font {<BR>
&nbsp;&nbsp;PSFont(<BR>
&nbsp;&nbsp;const char* psname, Coord size, const char* encoding, float scale<BR>
&nbsp;&nbsp;);<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 6.3: Font and PSFont class interfaces
<BR>
<A NAME="PAGE41"></A>
&nbsp;&nbsp;</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Transformer::premultiply and Transformer::postmultiply set the matrix to be<BR>
the result of multiplying the matrix and the given matrix. Two operations are<BR>
necessary because matrix multiplication is not commutative for 2D coordinates.<BR>
Premultiply means the current matrix is on the left-hand side of the multiplication,<BR>
postmultiply means the current matrix is on the right. Transformer::invert sets the<BR>
matrix to its inverse.<BR>
&nbsp;&nbsp;Transformer::translate modifies the matrix to add </FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
dx </FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
to the x coordinate and </FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
dy<BR>
</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
to the y coordinate. Transformer::scale modifies the matrix to multiply the x and<BR>
y coordinates by </FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
sx </FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
and </FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
sy, </FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
respectively. Transformer::rotate modifies the matrix<BR>
to rotate x and y coordinates by a given angle in degrees. Transformer::skew<BR>
modifies the matrix to skew coordinates by </FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
sx </FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
and </FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
sy.<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Transformer::transform multiplies the given coordinates by the matrix to<BR>
compute transformed coordinates. The coordinates can either transformed in<BR>
place stored in specific out parameters (tx, ty). Transformer::inverse_transform<BR>
performs the inverse mapping; taking transformed coordinates and returning the<BR>
original coordinates.<BR>
&nbsp;&nbsp;The following example shows how to use transformers:<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
Transformer t; // start with identity<BR>
&nbsp;&nbsp;t.rotate(90.0);<BR>
&nbsp;&nbsp;t.translate(20.0, 10.0);<BR>
&nbsp;&nbsp;t.scale(0.5, 0.5);<BR>
&nbsp;&nbsp;float x = 1.0, y = 0.0;<BR>
&nbsp;&nbsp;float tx, ty;<BR><BR><BR><BR><BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
6- 5 6- 5
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
interface Transformer : Resource {<BR>
&nbsp;&nbsp;Transformer();<BR>
&nbsp;&nbsp;Transformer(<BR>
&nbsp;&nbsp;float a00, float a01, float a10, float a11, float a20, float a21<BR>
&nbsp;&nbsp;);<BR>
&nbsp;&nbsp;boolean identity() const;<BR>
&nbsp;&nbsp;void premultiply(const Transformer&);<BR>
&nbsp;&nbsp;void postmultiply(const Transformer&);<BR>
&nbsp;&nbsp;void invert();<BR>
&nbsp;&nbsp;void translate(float dx, float dy);<BR>
&nbsp;&nbsp;void scale(float sx, float sy);<BR>
&nbsp;&nbsp;void rotate(float angle);<BR>
&nbsp;&nbsp;void skew(float sx, float sy);<BR>
&nbsp;&nbsp;void transform(floatx, floaty);<BR>
&nbsp;&nbsp;void transform(float x, float y, floattx, floatty);<BR>
&nbsp;&nbsp;void inverse_transform(floatx, floaty);<BR>
&nbsp;&nbsp;void inverse_transform(float tx, float ty, floatx, floaty);<BR>
&nbsp;&nbsp;void matrix(floata00, floata01, floata10, floata11, floata20, floata21);<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 6.4: Transformer protocol
<BR>
<A NAME="PAGE42"></A>
&nbsp;&nbsp;t.transform(x, y, tx, ty);<BR>
&nbsp;&nbsp;// now tx = 10.0, ty = 5.5<BR>
</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Although the transformation is a single step, one can think of it as individual steps<BR>
for each of the rotate, translate, and scale steps. First the given point (1.0,0.0) is<BR>
rotated to (0.0,1.0), then it is translated to (20.0,11.0), finally it is scaled to<BR>
(10.0,5.5).<BR>
</FONT>
<FONT SIZE=4>
<!-- /Times-Bold -->
<B>6.1.5 Bitmap<BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
A bitmap is a two-dimensional array of boolean values. A bitmap is useful for<BR>
stenciling; that is, drawing through a mask that allows some pixels to be drawn<BR>
but prevents others from being changed. The Stencil class can be used to put a<BR>
bitmap in a glyph graph.<BR>
&nbsp;&nbsp;Figure 6.5 shows the Bitmap class interface. There are two constructors<BR>
for bitmaps. One takes the bitmap data, width, height, and origin. The other<BR>
constructor creates a bitmap for a given character in a font, optionally scaling by a<BR>
given factor. In this case, the bitmap width and height will reflect the actual size<BR>
of the character glyph and the bitmap origin will be the same as the character<BR>
origin.<BR>
&nbsp;&nbsp;Bitmap::open operation tries to open a file containing a bitmap definition in the<BR>
format produced by the X bitmap program. If the file is found and is a valid<BR>
format, open returns true and sets the bitmap information.<BR>
&nbsp;&nbsp;Bitmap::peek and Bitmap::poke are used to read and write at specified positions<BR>
in the bitmap. Bitmap::width and Bitmap::height return the width and height of<BR>
the bitmap in coordinates, while Bitmap::pwidth and Bitmap::pheight return the<BR>
number of bits defined in each dimension.<BR>
&nbsp;&nbsp;Treating the bitmap origin as (0,0), Bitmap::left_bearing, Bitmap::right_bearing,<BR>
Bitmap::ascent, and Bitmap::descent return the left, right, top, and bottom<BR>
coordinates of the bitmap, respectively. For example, a 16x16 bitmap with its<BR>
origin at (7,5) would have a left_bearing of -7, a right_bearing of 9, an ascent of<BR>
12, and a descent of -5.<BR><BR><BR><BR><BR>
&nbsp;&nbsp;6- 6 6- 6
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
interface Bitmap : Resource {<BR>
&nbsp;&nbsp;Bitmap(<BR>
&nbsp;&nbsp;void*, unsigned int width, unsigned int height, int x0 = -1, int y0 = -1<BR>
&nbsp;&nbsp;);<BR>
&nbsp;&nbsp;Bitmap(Font*, int code, float scale = 1.0);<BR>
&nbsp;&nbsp;static Bitmap* open(const char* filename);<BR>
&nbsp;&nbsp;void poke(boolean set, unsigned int x, unsigned int y);<BR>
&nbsp;&nbsp;void peek(unsigned int x, unsigned int y);<BR>
&nbsp;&nbsp;Coord width() const, height() const;<BR>
&nbsp;&nbsp;unsigned int pwidth() const, pheight() const;<BR>
&nbsp;&nbsp;Coord left_bearing() const, right_bearing() const;<BR>
&nbsp;&nbsp;Coord ascent() const, descent() const;<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 6.5: Bitmap protocol
<BR>
<A NAME="PAGE43"></A>
</FONT>
<FONT SIZE=4>
<!-- /Times-Bold -->
<B>6.1.6 Raster<BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
A raster is a color image specified by a two-dimensional array of colors. The<BR>
Image class can be used to put a raster in a glyph graph. The TIFFRaster class<BR>
provides a single operation, load, for reading a TIFF image file and creating a<BR>
raster for it. If the file is not readable or not a valid TIFF file, TIFFRaster::load<BR>
will return nil.<BR>
&nbsp;&nbsp;Figure 6.6 shows the Raster and TIFFRaster class interfaces. The raster<BR>
constructor is given the size of the array of colors. Raster::width and<BR>
Raster::height return the dimensions of the raster in coordinates, while<BR>
Raster::pwidth and Raster::pheight return the dimensions of the array. A raster's<BR>
origin is always the lower left corner.<BR>
&nbsp;&nbsp;Raster::peek and Raster::poke read and write the color array, accessing colors<BR>
in terms of the RGB intensities and an alpha value. Peek and poke operations are<BR>
guaranteed to be cheap; that is, any processing (especially interaction with the<BR>
window system) will be deferred until the raster is next displayed.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>6.2 Canvas<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
A canvas is a 2-dimensional area on which to draw. The base implementation<BR>
draws on a portion of the screen, normally created by a window object rather<BR>
than directly by an application. The Printer subclass uses the same rendering<BR>
operations to generate PostScript to a file. Thus, it is possible to write a single<BR>
drawing routine that can be used to generate screen or printer output.<BR>
&nbsp;&nbsp;Figure 6.7 shows the canvas and printer operations. For screen canvases,<BR>
Canvas::window returns the window containing the canvas; otherwise it returns<BR><BR><BR><BR><BR>
&nbsp;&nbsp;6- 7 6- 7
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
interface Raster : Resource {<BR>
&nbsp;&nbsp;Raster(unsigned int pwidth, unsigned int pheight);<BR>
&nbsp;&nbsp;Coord width() const, height() const;<BR>
&nbsp;&nbsp;unsigned int pwidth() const, pheight() const;<BR>
&nbsp;&nbsp;void peek(<BR>
&nbsp;&nbsp;unsigned int x, unsigned int y,<BR>
&nbsp;&nbsp;ColorIntensity& r, ColorIntensity& g, ColorIntensity& b, float& alpha<BR>
&nbsp;&nbsp;) const;<BR>
&nbsp;&nbsp;void poke(<BR>
&nbsp;&nbsp;unsigned int x, unsigned int y,<BR>
&nbsp;&nbsp;ColorIntensity r, ColorIntensity g, ColorIntensity b, float alpha<BR>
&nbsp;&nbsp;);<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;interface TIFFRaster {<BR>
&nbsp;&nbsp;static Raster* load(const char* filename);<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 6.6: Raster and TIFFRaster protocols
<BR>
<A NAME="PAGE44"></A>
</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
nil. Canvas::width and Canvas::height return the dimensions of the canvas in<BR>
coordinates.<BR>
&nbsp;&nbsp;The canvas rendering operations are similar to the PostScript<BR>
drawing operations. Canvas::new_path, Canvas::move_to, Canvas::line_to,<BR>
Canvas::curve_to, and Canvas::close_path are used to define a list of coordinates<BR>
on which to perform a drawing operation. Canvas::move_to sets the position in<BR>
the path, and Canvas::line_to extends the path to a new position. Canvas::curve_to<BR>
also extends the path, but with a Bezier curve between the old and new positions.<BR>
Canvas::close_path closes the path. Canvas::stroke draws along the current path<BR>
with a given brush and color. Canvas::fill draws inside the path with a given<BR>
color. Canvas::clip restricts subsequent drawing to be inside the path. Clipping is<BR>
cumulative; that is, two consecutive clip operations will result in a clipping region<BR>
that is the intersection of the paths specified by the two requests.<BR>
&nbsp;&nbsp;Canvas::line, Canvas::rect, Canvas::fill_rect, and Canvas::clip_rect are provided<BR>
for convenience. Canvas::line is equivalent to stroking a path with two points,<BR>
Canvas::rect strokes a rectangular path, Canvas::fill_rect fills a rectangular path,<BR>
and Canvas::clip_rect restricts subsequent output to be within a rectangular path.<BR>
&nbsp;&nbsp;Drawing operations are typically batched to improve performance. For<BR>
example, a series of Canvas::character operations might be combined into a single<BR>
request on many graphics systems. An application cannot determine if or when a<BR>
particular operation has completed. No synchronization operations are defined on<BR>
a canvas, as several canvases may be active at the same time. Display::flush or<BR>
Display::sync can be used to wait until the display starts or finishes drawing,<BR>
respectively.<BR>
&nbsp;&nbsp;As an example of the drawing operations, the following code draws a filled<BR>
triangle with corners (x1,y1), (x2,y2), and (x3,y3):<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
canvas->new_path();<BR>
&nbsp;&nbsp;canvas->move_to(x1, y1);<BR>
&nbsp;&nbsp;canvas->line_to(x2, y2);<BR>
&nbsp;&nbsp;canvas->line_to(x3, y3);<BR>
&nbsp;&nbsp;canvas->close_path();<BR>
&nbsp;&nbsp;canvas->fill(color);<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>6.3 Printer<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
A printer is a 2-D drawing surface like a canvas, but that generates output for<BR>
hardcopy or previewing. The printer class normally generates PostScript text to a<BR>
file; other printer formats may be available at a particular site.<BR>
&nbsp;&nbsp;Printer is a subclass of Canvas with different implementations for the drawing<BR>
operations. Thus, a printer can be passed to an operation expecting a canvas. The<BR>
printer class also provides a few additional operations.<BR>
&nbsp;&nbsp;The printer constructor takes a pointer to an output stream where the print<BR>
representation will be written. Printer::resize specifies the boundaries of the<BR>
printed page. Printer::comment generates text that will appear in the output<BR>
&nbsp;&nbsp;6- 8 6- 
<BR>
<A NAME="PAGE45"></A>
stream, but will not show on the printed page. Printer::page generates information<BR>
about the current page. This operation will not result in any printed output, but is<BR>
used by previewers. Printer::flush forces any locally-buffered data to be written.<BR><BR><BR><BR><BR>
&nbsp;&nbsp;6- 9 6- 9
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
interface Canvas {<BR>
&nbsp;&nbsp;Window* window() const;<BR>
&nbsp;&nbsp;Coord width() const, height() const;<BR>
&nbsp;&nbsp;PixelCoord to_pixels(Coord) const;<BR>
&nbsp;&nbsp;Coord to_coord(PixelCoord) const;<BR>
&nbsp;&nbsp;Coord to_pixels_coord(Coord) const;<BR>
&nbsp;&nbsp;void new_path();<BR>
&nbsp;&nbsp;void move_to(Coord x, Coord y);<BR>
&nbsp;&nbsp;void line_to(Coord x, Coord y);<BR>
&nbsp;&nbsp;void curve_to(Coord x, Coord y, Coord x1, Coord y1, Coord x2, Coord y2);<BR>
&nbsp;&nbsp;void close_path();<BR>
&nbsp;&nbsp;void stroke(const Color*, const Brush*);<BR>
&nbsp;&nbsp;void rect(Coord l, Coord b, Coord r, Coord t, const Color*, const Brush*);<BR>
&nbsp;&nbsp;void fill(const Color*);<BR>
&nbsp;&nbsp;void fill_rect(Coord l, Coord b, Coord r, Coord t, const Color*);<BR>
&nbsp;&nbsp;void character(<BR>
&nbsp;&nbsp;const Font*, int ch, Coord width, const Color*, Coord x, Coord y<BR>
&nbsp;&nbsp;);<BR>
&nbsp;&nbsp;void stencil(const Bitmap*, const Color*, Coord x, Coord y);<BR>
&nbsp;&nbsp;void image(const Raster*, Coord x, Coord y);<BR>
&nbsp;&nbsp;void push_transform(), pop_transform();<BR>
&nbsp;&nbsp;void transform(const Transformer&);<BR>
&nbsp;&nbsp;void transformer(const Transformer&);<BR>
&nbsp;&nbsp;const Transformer& transformer() const;<BR>
&nbsp;&nbsp;void push_clipping(), pop_clipping();<BR>
&nbsp;&nbsp;void clip();<BR>
&nbsp;&nbsp;void clip_rect(Coord l, Coord b, Coord r, Coord t);<BR>
&nbsp;&nbsp;void damage(const Extension&);<BR>
&nbsp;&nbsp;void damage(Coord l, Coord b, Coord r, Coord t);<BR>
&nbsp;&nbsp;boolean damaged(const Extension&) const;<BR>
&nbsp;&nbsp;boolean damaged(Coord l, Coord b, Coord r, Coord t) const;<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;interface Printer : Canvas {<BR>
&nbsp;&nbsp;Printer(ostream*);<BR>
&nbsp;&nbsp;void resize(Coord left, Coord bottom, Coord right, Coord top);<BR>
&nbsp;&nbsp;void comment(const char*);<BR>
&nbsp;&nbsp;void page(const char*);<BR>
&nbsp;&nbsp;void flush();<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 6.7: Canvas and printer protocols
<BR>
<A NAME="PAGE46"></A>
</FONT>
<FONT SIZE=9>
<!-- /Times-Bold -->
<B>Chapter 8<BR>
Styles<BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
User interface toolkits traditionally have coupled the management of style<BR>
attributes such as color and font with the composition of objects in a window.<BR>
This coupling is too rigid and inefficient for many applications because attributes<BR>
are <!-- /Times-Italic -->
<I>logical </I><!-- /Times-Roman -->
information, whereas composition is a <!-- /Times-Italic -->
<I>physical </I><!-- /Times-Roman -->
organization. For<BR>
example, a document logically contains text and graphics organized into chapters,<BR>
sections, subsections, and paragraphs. Physically, the document contains lines,<BR>
columns, and pages. The font of a string of characters in the document is<BR>
independent of whether there is a line break within the string or not, thus the style<BR>
information is orthogonal to the layout.<BR>
&nbsp;&nbsp;InterViews provides a <!-- /Times-Italic -->
<I>style </I><!-- /Times-Roman -->
class for organizing user interface attributes. A<BR>
style is similar to an environment in a text formatting system such as Scribe.<BR>
Styles may be nested hierarchically, and attributes defined in an outer style are<BR>
visible in an inner style if not otherwise defined. A style consists of an optional<BR>
name, an optional list of prefixes for wildcard-matching, a collection of attributes<BR>
(name-value pairs), a collection of styles nested inside the style, and a parent style.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>8.1 Defining a style<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Figure 8.1 shows the style class operations for creating and accessing simple<BR>
style information. When a style is created, its name and parent style may be<BR>
specified. The default parent style is nil. Style::name sets or gets the style's<BR>
name. Style::parent gets the style's parent. The parent cannot be set directly, but<BR>
can be changed by appending the style to its (new) parent.<BR>
&nbsp;&nbsp;Style::append and Style::remove add and delete a style from the list of styles<BR>
nested inside another style. Style::children returns the number of nested styles.<BR>
Style::child returns the indexed child in the list. Style::find_style returns the<BR>
nested style with the given name or nil if there is none.<BR>
&nbsp;&nbsp;Style::attribute adds a <name,value> pair to the list of attributes in the style. If<BR>
an attribute is already defined with the name, the value will be updated unless<BR>
the specified priority is lower than the already-defined priority of the attribute<BR>
Style::remove_attribute deletes the named attribute from the style's attribute list.<BR>
Style::attributes and the get form of Style::attribute can be used to retrieve all the<BR>
attributes defined on a style. The order of the list is arbitrary.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>8.2 Finding an attribute<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
The style class provides two overloaded functions for finding an attribute value<BR>
&nbsp;&nbsp;8- 
<BR>
<A NAME="PAGE47"></A>
given the name. Style::find_attribute takes two parameters and returns a boolean<BR>
value that is true if the attribute is found and false otherwise. The first parameter<BR>
is the desired name, which can either be passed as a String object or a <!-- /Times-Italic -->
<I>const<BR>
char*. </I><!-- /Times-Roman -->
The second parameter is a reference to where the value of the attribute<BR>
should be stored if found. If the parameter is a string, then the value is simply<BR>
copied directly. If it is a long or double, then value string is converted to a<BR>
number. If the result parameter is a Coord, then the value string is converted to a<BR>
number and multiplied by the units specified in the value string after the number.<BR>
The unit specification can be #inº for inches, #cmº for centimeters, #mmº for<BR>
millimeters, #emº for the width in points of the character #mº in the style's font,<BR>
and #ptº for points.<BR>
&nbsp;&nbsp;The other function for finding an attribute is Style::value_is_on. This function<BR>
is equivalent to calling Style::find_attribute and testing if the value string is #onº<BR>
or #trueº. The test is case-insensitive.<BR><BR><BR>
&nbsp;&nbsp;8- 2
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
interface Style : Resource {<BR>
&nbsp;&nbsp;Style();<BR>
&nbsp;&nbsp;Style(const String& name);<BR>
&nbsp;&nbsp;Style(Style* parent);<BR>
&nbsp;&nbsp;Style(const String& name, Style* parent);<BR>
&nbsp;&nbsp;void name(const String&);<BR>
&nbsp;&nbsp;const String* name() const;<BR>
&nbsp;&nbsp;void alias(const String&);<BR>
&nbsp;&nbsp;long alias_count() const;<BR>
&nbsp;&nbsp;const String* alias(long) const;<BR>
&nbsp;&nbsp;Style* parent() const;<BR>
&nbsp;&nbsp;void append(Style*);<BR>
&nbsp;&nbsp;void remove(Style*);<BR>
&nbsp;&nbsp;long children() const;<BR>
&nbsp;&nbsp;Style* child(long) const;<BR>
&nbsp;&nbsp;void attribute(const String& name, const String& value, int priority = 0);<BR>
&nbsp;&nbsp;void remove_attribute(const String& name);<BR>
&nbsp;&nbsp;long attributes() const;<BR>
&nbsp;&nbsp;boolean attribute(long, String& name, String& value) const;<BR>
&nbsp;&nbsp;void add_trigger(const String& , Action*);<BR>
&nbsp;&nbsp;void remove_trigger(const String&, Action* = nil);<BR>
&nbsp;&nbsp;void add_trigger_any(Action*);<BR>
&nbsp;&nbsp;void remove_trigger_any(Action*);<BR>
&nbsp;&nbsp;boolean find_attribute(const String&, String& value) const;<BR>
&nbsp;&nbsp;boolean find_attribute(const String&, long&) const;<BR>
&nbsp;&nbsp;boolean find_attribute(const String&, double&) const;<BR>
&nbsp;&nbsp;boolean find_attribute(const String&, Coord&) const;<BR>
&nbsp;&nbsp;boolean value_is_on(const String&);<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 8.1: Style protocol.
<BR>
<A NAME="PAGE48"></A>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>8.3 Wildcard matching<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Attribute names may contain #*º characters to specify wildcard matching. A<BR>
name of the form A*B will match an attribute B in a nested style named A.<BR>
Wildcard names also may begin with a #*º, which matches in any descendant<BR>
style. Thus, *A*B will match an attribute B in any descendant style named A.<BR>
Because attributes are inherited, specifying the wildcard name *B is identical to<BR>
specifying the normal attribute B.<BR>
&nbsp;&nbsp;In addition to a name, styles may have a list of associated aliases. Style::alias<BR>
prepends a string to the list. Wildcard matches search using a style's name first,<BR>
then search using the style's aliases in the reverse order in which they are defined.<BR>
Aliases are typically used for indicating a subclass relationship and allowing<BR>
styles to inherit attributes specified for a superclass.<BR>
&nbsp;&nbsp;For example, suppose the root style defines the following attributes:<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
*Mover*autorepeat:off<BR>
&nbsp;&nbsp;*UpMover*autorepeat:on<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Consider descendant styles S and T: S's aliases are UpMover and Mover; T's<BR>
aliases are DownMover and Mover. Style::find_attribute for #autorepeatº will<BR>
return #onº for S, #offº for T.<BR>
&nbsp;&nbsp;The wildcard matching algorithm is compatible with the X resource manager to<BR>
support the same user customization functionality. Wildcard attributes typically<BR>
are defined only on the root style, as loaded from the window system, application<BR>
defaults files, or command-line arguments.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>8.4 Using styles with glyphs<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Glyphs that draw typically contain the specific style information they need to<BR>
render. For example, a character glyph contains the font and color it uses to draw.<BR>
Higher level glyphs, such as a slider for scrolling, contain a style from which<BR>
they construct their components. When styles support trigger routines to detect<BR>
attribute value changes, these higher-level components will be able to reconstruct<BR>
their contents automatically.<BR>
&nbsp;&nbsp;Figure 8.2 shows a function that builds a vertical scrollbar by creating a<BR>
box containing an up-mover (button with up-arrow), a scroller (slider), and a<BR>
down-mover (button with down-arrow). The function creates a new style and<BR>
gives it the prefixes VScrollBar and ScrollBar for customization. If the attribute<BR>
#mover_sizeº is defined on the style, then its value will override the default (15.0).<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>8.5 Summary<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
User interface geometry and attribute management are two different problems that<BR>
&nbsp;&nbsp;8- 
<BR>
<A NAME="PAGE49"></A>
are best solved independently. Whereas glyphs define a physical organization<BR>
with a directed acyclic graph, styles define a logical organization with a strict<BR>
hierarchy. Both structures are simple and the connection between them is<BR>
straightforward.<BR>
&nbsp;&nbsp;Styles provide a unified framework for managing user-customizable attributes,<BR>
document formatting information, and structured graphics state. Style prefixes<BR>
support wildcarding and allow the decoupling of the implementation class<BR>
hierarchy from the logical class hierarchy offered to the user for the purposes<BR>
of customization. This approach makes applications simpler to develop, more<BR>
consistent to use, and easier to integrate.<BR><BR><BR><BR><BR>
&nbsp;&nbsp;8- 
<BR>
<A NAME="PAGE50"></A>
&nbsp;&nbsp;8- 5
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
Glyph* vscroll_bar(Adjustable* a) {<BR>
&nbsp;&nbsp;WidgetKit& kit = *WidgetKit::instance();<BR>
&nbsp;&nbsp;const LayoutKit& layout = *LayoutKit::instance();<BR>
&nbsp;&nbsp;kit.begin_style("VScrollBar");<BR>
&nbsp;&nbsp;kit.alias("ScrollBar");<BR>
&nbsp;&nbsp;Style* s = kit.style();<BR>
&nbsp;&nbsp;Coord mover_size = 15.0;<BR>
&nbsp;&nbsp;s->find_attribute("mover_size", mover_size);<BR>
&nbsp;&nbsp;Glyph* sep = layout.vspace(1.0);<BR>
&nbsp;&nbsp;return kit.inset_frame(<BR>
&nbsp;&nbsp;layout.vbox(<BR>
&nbsp;&nbsp;layout.v_fixed_span(up_mover(a, s), mover_size),<BR>
&nbsp;&nbsp;sep,<BR>
&nbsp;&nbsp;new VScroller(a, s),<BR>
&nbsp;&nbsp;sep,<BR>
&nbsp;&nbsp;layout.v_fixed_span(down_mover(a, s), mover_size)<BR>
&nbsp;&nbsp;),<BR>
&nbsp;&nbsp;s<BR>
&nbsp;&nbsp;);<BR>
&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;Figure 8.2: Using styles to build glyphs.
<BR>
<A NAME="PAGE51"></A>
</FONT>
<FONT SIZE=9>
<!-- /Times-Bold -->
<B>Chapter 9<BR>
WidgetKit<BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
WidgetKit defines operations for creating user interface objects with a concrete<BR>
look-and-feel. Typically, an application uses a widget kit to create specific<BR>
components, such as pulldown menus, push buttons, and scrollbars. WidgetKit<BR>
isolates the application from specific look-and-feel issues and the details of how<BR>
a concrete component is implemented. Many components are defined using<BR>
instances of existing classes. For example, a push button with a string label is<BR>
created using a button, label, and two bevel objects.<BR>
&nbsp;&nbsp;InterViews provides a base widget kit class for creating common user interface<BR>
objects. Subclasses are provided for implementing concrete objects based on the<BR>
Motif (default) and OpenLook user interfaces.<BR>
&nbsp;&nbsp;WidgetKit::instance is a static member function that returns a default kit. If a<BR>
kit has not yet been created, WidgetKit::instance creates one using the session's<BR>
style to determine which kit subclass to construct.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>9.1 Style management<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
WidgetKit maintains a current style for use in customizing widgets. The initial<BR>
style is the root style for all windows. WidgetKit defines the operations shown in<BR>
Figure 9.1 for querying and modifying the style.<BR>
&nbsp;&nbsp;WidgetKit::style sets or gets the current style. When the style is set or changed<BR>
via a Style::attribute call, WidgetKit::style_changed is called to allow WidgetKit<BR>
subclasses to recompute information associated with the current style (such as<BR>
colors for shading).<BR>
&nbsp;&nbsp;WidgetKit::begin_style sets the current style to a newly-created style that is<BR>
a child of the current style. The given string is the name of the new style.<BR>
WidgetKit::alias adds an alias name for the current style. Widget::end_style<BR><BR><BR><BR><BR>
&nbsp;&nbsp;9- 1
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
void style(Style*);<BR>
&nbsp;&nbsp;Style* style() const;<BR>
&nbsp;&nbsp;void begin_style(const String&), end_style();<BR>
&nbsp;&nbsp;void alias(const String&);<BR>
&nbsp;&nbsp;void push_style(), pop_style();<BR>
&nbsp;&nbsp;void style_changed(Style*);<BR>
&nbsp;&nbsp;const Font* font() const;<BR>
&nbsp;&nbsp;const Color* foreground() const;<BR>
&nbsp;&nbsp;const Color* background() const;<BR>
&nbsp;&nbsp;Figure 9.1: WidgetKit operations for style management
<BR>
<A NAME="PAGE52"></A>
</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
returns the current style to what it was before the call to WidgetKit::begin_style.<BR>
WidgetKit::push_style and pop_style save and restore the current style on a stack.<BR>
&nbsp;&nbsp;WidgetKit::font, foreground, and background return specific attribute<BR>
information for the current style. These operations are equivalent to (though<BR>
potentially faster than) finding the string value of a style attribute and then<BR>
looking up the resource with the given name. For example, WidgetKit::font is<BR>
the same as finding the attribute named #fontº and calling Font::lookup on the<BR>
attribute's value.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>9.2 Common cursors<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
WidgetKit provides operations to retrieve commonly-used cursors that might be<BR>
shared among several widgets. Figure 9.2 shows the currently-defined operations.<BR>
WidgetKit::hand_cursor is the outline of a small hand. WidgetKit::lfast_cursor<BR>
is a double-arrow pointing to the left that is typically used in continuous rate<BR>
scrolling. Similarly, the other #fastº cursors are double-arrows pointing in various<BR>
directions.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>9.3 Bevels<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
On color displays, it is often desirable to frame objects with a beveled look to give<BR>
a 3D appearance. WidgetKit provides the following three functions for creating<BR>
beveled frames:<BR>
&nbsp;&nbsp;Glyph* inset_frame(Glyph*) const;<BR>
&nbsp;&nbsp;Glyph* outset_frame(Glyph*) const;<BR>
&nbsp;&nbsp;Glyph* bright_inset_frame(Glyph*) const;<BR>
WidgetKit:inset_frame uses dark shading in the upper left and light shading<BR>
in the lower right to make the contents of the frame appear to be recessed.<BR>
WidgetKit::outset_frame reverses the shading to make the contents appear to<BR>
project out of the frame. WidgetKit::bright_inset_frame is like inset_frame but<BR>
uses a brighter background color and is thinner.<BR>
&nbsp;&nbsp;9- 2
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
Cursor* hand_cursor() const;<BR>
&nbsp;&nbsp;Cursor* lfast_cursor() const;<BR>
&nbsp;&nbsp;Cursor* lufast_cursor() const;<BR>
&nbsp;&nbsp;Cursor* ufast_cursor() const;<BR>
&nbsp;&nbsp;Cursor* rufast_cursor() const;<BR>
&nbsp;&nbsp;Cursor* rfast_cursor() const;<BR>
&nbsp;&nbsp;Cursor* rdfast_cursor() const;<BR>
&nbsp;&nbsp;Cursor* dfast_cursor() const;<BR>
&nbsp;&nbsp;Cursor* ldfast_cursor() const;<BR>
&nbsp;&nbsp;Figure 9.2: WidgetKit cursors
<BR>
<A NAME="PAGE53"></A>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>9.4 Labels<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
A label is a string of text with the current style's font and color. WidgetKit<BR>
provides two operations for creating labels:<BR>
&nbsp;&nbsp;Glyph* label(const char*) const;<BR>
&nbsp;&nbsp;Glyph* label(const String&) const;<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>9.5 Buttons<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
A button is an input handler that can perform an action when pressed. Buttons<BR>
manipulate a <!-- /Times-Italic -->
<I>telltale state </I><!-- /Times-Roman -->
object so that views (which are typically part of the<BR>
button's body) can reflect the current state visually. The button itself is a view so<BR>
that it can damage the canvas when appropriate, freeing other views from the need<BR>
to store update information.<BR>
&nbsp;&nbsp;A telltale state can be part of a <!-- /Times-Italic -->
<I>telltale group. </I><!-- /Times-Roman -->
When one member of a group is<BR>
chosen, then the currently chosen state becomes unchosen. Telltale groups are<BR>
useful for implementing radio buttons.<BR>
&nbsp;&nbsp;Figure 9.3 shows the button, telltale state, and telltale group protocols.<BR>
Button just provides operations to access the associated telltale state and action.<BR>
TelltaleState defines a set of flags that define the current state. TelltaleState::set<BR>
and TelltaleState::test modify and query the current state, respectively.<BR>
TelltaleState::join and TelltaleState::leave_group allow the state to be associated<BR>
with a group.<BR>
&nbsp;&nbsp;Figure 9.4 shows the WidgetKit operations that return buttons. Push button,<BR>
default button, and palette button typically have a similar appearance. Neither a<BR>
push button or a default button can be chosen, whereas a palette button can. A<BR>
default button might have a different appearance to indicate to the user that it is<BR>
the common choice.<BR>
&nbsp;&nbsp;A check box is a toggle button: choosing it when already chosen will cause it to<BR>
become unchosen. A radio button must belong to a telltale group so that within<BR>
the group only one button is chosen at any given time.<BR>
&nbsp;&nbsp;For application-specific actions, it is necessary to define action callbacks for the<BR>
relevant application classes. In the case of quitting the application WidgetKit::quit<BR>
can be used to return an action that calls Session::quit.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>9.6 Menus<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
A menu is similar to a group of related buttons, called menu items. Like a button,<BR>
the look of a menu item is dependant on a telltalestate. Menu items can have<BR>
associated actions that are executed when the item is chosen. Menus items can<BR>
also have associated nested menus, in which case the submenu is opened when the<BR>
&nbsp;&nbsp;9- 
<BR>
<A NAME="PAGE54"></A>
item is highlighted. Figure 9.5 shows the WidgetKit menu operations and the<BR>
menu item and menu protocols.<BR>
&nbsp;&nbsp;WidgetKit::menubar creates a horizontal menu with a small amount of white<BR>
space between items. WidgetKit::pulldown and WidgetKit::pullright create<BR>
vertical menus. The top of a pulldown menu will be aligned to the bottom of the<BR>
menubar, while a pullright's top will be aligned to the top right of its containing<BR>
item.<BR>
&nbsp;&nbsp;WidgetKit::menubar_item creates an item centered horizontally with a small<BR>
amount of white space on each side. WidgetKit::menu_item creates a left-adjusted<BR>
item, WidgetKit::check_menu_item creates a toggle item that looks like a check<BR>
box when chosen. WidgetKit::radio_menu_item creates an item that looks like<BR>
a radio button. WidgetKit::menu_item_separator returns an item for visually<BR>
separating other items (such as a horizontal line).<BR><BR><BR>
&nbsp;&nbsp;9- 4
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
interface Button : ActiveHandler, Observer {<BR>
&nbsp;&nbsp;Button(Glyph*, Style*, TelltaleState*, Action*);<BR>
&nbsp;&nbsp;TelltaleState* state() const;<BR>
&nbsp;&nbsp;Action* action() const;<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;typedef unsigned int TelltaleFlags;<BR>
&nbsp;&nbsp;interface TelltaleState : Resource, Observable {<BR>
&nbsp;&nbsp;TelltaleState(const TelltaleFlags = 0);<BR>
&nbsp;&nbsp;enum {<BR>
<CENTER>
is_enabled, is_visible, is_enabled_visible, is_active, is_enabled_active,<BR>
</CENTER>
&nbsp;&nbsp;is_visible_active, is_enabled_visible_active, is_chosen, is_enabled_chosen,<BR>
&nbsp;&nbsp;is_visible_chosen, is_enabled_visible_chosen,<BR>
&nbsp;&nbsp;is_enabled_active_chosen, is_active_chosen,<BR>
&nbsp;&nbsp;is_visible_active_chosen, is_enabled_visible_active_chosen,<BR>
&nbsp;&nbsp;is_running, is_choosable, is_toggle,<BR>
&nbsp;&nbsp;max_flags<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;TelltaleFlags flags() const;<BR>
&nbsp;&nbsp;void set(const TelltaleFlags, boolean);<BR>
&nbsp;&nbsp;boolean test(const TelltaleFlags) const;<BR>
&nbsp;&nbsp;void join(TelltaleGroup*);<BR>
&nbsp;&nbsp;void leave_group();<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;interface TelltaleGroup : Resource {<BR>
&nbsp;&nbsp;void update(TelltaleState*);<BR>
&nbsp;&nbsp;void remove(TelltaleState*);<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 9.3: Button, TelltaleState, and TelltaleGroup protocols.
<BR>
<A NAME="PAGE55"></A>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>9.7 Adjusters<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Scrollbars and mover buttons are examples of interactive objects that #adjustº the<BR>
view shown by another object. WidgetKit provides the operations shown in<BR>
Figure 9.6 to create common adjusters.<BR>
&nbsp;&nbsp;WidgetKit::hscroll_bar and WidgetKit::vscroll_bar return controls for scrolling<BR>
a view in the horizontal and vertical dimensions, respectively. WidgetKit::panner<BR>
returns a control for scrolling two adjustables at once. One adjustable is controlled<BR>
by the horizontal position of the panner, one by the vertical position. Typically,<BR>
the same adjustable is passed to both parameters when creating a panners.<BR><BR><BR><BR><BR>
&nbsp;&nbsp;9- 5
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
Button* push_button(const String&, Action*) const;<BR>
&nbsp;&nbsp;Button* push_button(Glyph*, Action*) const;<BR>
&nbsp;&nbsp;Button* default_button(const String&, Action*) const;<BR>
&nbsp;&nbsp;Button* default_button(Glyph*, Action*) const;<BR>
&nbsp;&nbsp;Button* palette_button(const String&, Action*) const;<BR>
&nbsp;&nbsp;Button* palette_button(Glyph*, Action*) const;<BR>
&nbsp;&nbsp;Button* check_box(const String&, Action*) const;<BR>
&nbsp;&nbsp;Button* check_box(Glyph*, Action*) const;<BR>
&nbsp;&nbsp;Button* radio_button(TelltaleGroup*, const String&, Action*) const;<BR>
&nbsp;&nbsp;Glyph* push_button_look(Glyph*, TelltaleState*) const;<BR>
&nbsp;&nbsp;Glyph* default_button_look(Glyph*, TelltaleState*) const;<BR>
&nbsp;&nbsp;Glyph* palette_button_look(Glyph*, TelltaleState*) const;<BR>
&nbsp;&nbsp;Glyph* check_box_look(Glyph*, TelltaleState*) const;<BR>
&nbsp;&nbsp;Glyph* radio_button_look(Glyph*, TelltaleState*) const;<BR>
&nbsp;&nbsp;Figure 9.4: WidgetKit button operations
<BR>
<A NAME="PAGE56"></A>
&nbsp;&nbsp;</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
9- 6
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
Menu* menubar() const, * pulldown() const, * pullright() const;<BR>
&nbsp;&nbsp;MenuItem* menubar_item(const String&) const;<BR>
&nbsp;&nbsp;MenuItem* menubar_item(Glyph*) const;<BR>
&nbsp;&nbsp;MenuItem* menu_item(const String&) const;<BR>
&nbsp;&nbsp;MenuItem* menu_item(Glyph*) const;<BR>
&nbsp;&nbsp;MenuItem* check_menu_item(const String&) const;<BR>
&nbsp;&nbsp;MenuItem* check_menu_item(Glyph*) const;<BR>
&nbsp;&nbsp;MenuItem* radio_menu_item(TelltaleGroup*, Glyph*) const;<BR>
&nbsp;&nbsp;MenuItem* menu_item_separator() const;<BR>
&nbsp;&nbsp;Glyph* menubar_look() const, pulldown_look() const, pullright_look() const;<BR>
&nbsp;&nbsp;Glyph* menubar_item_look(Glyph*, TelltaleState*) const;<BR>
&nbsp;&nbsp;Glyph* menu_item_look(Glyph*, TelltaleState*) const;<BR>
&nbsp;&nbsp;Glyph* check_menu_item_look(Glyph*, TelltaleState*) const;<BR>
&nbsp;&nbsp;Glyph* radio_menu_item _look(Glyph*, TelltaleState*) const;<BR>
&nbsp;&nbsp;Glyph* menu_item_separator_look() const;<BR>
&nbsp;&nbsp;interface MenuItem : Observer {<BR>
&nbsp;&nbsp;MenuItem(Glyph*, TelltaleState*);<BR>
&nbsp;&nbsp;Glyph* body() const;<BR>
&nbsp;&nbsp;TelltaleState* state() const;<BR>
&nbsp;&nbsp;void action(Action*);<BR>
&nbsp;&nbsp;Action* action() const;<BR>
&nbsp;&nbsp;void menu(Menu*, Window* = nil);<BR>
&nbsp;&nbsp;Menu* menu() const;<BR>
&nbsp;&nbsp;Window* window() const;<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;interface Menu : InputHandler {<BR>
&nbsp;&nbsp;Menu(Glyph*, Style*, float x1, float y1, float x2, float y2);<BR>
&nbsp;&nbsp;void append_item(MenuItem*);<BR>
&nbsp;&nbsp;void prepend_item(MenuItem*);<BR>
&nbsp;&nbsp;void insert_item(GlyphIndex, MenuItem*);<BR>
&nbsp;&nbsp;void remove_item(GlyphIndex);<BR>
&nbsp;&nbsp;void replace_item(GlyphIndex, MenuItem*);<BR>
&nbsp;&nbsp;GlyphIndex item_count() const;<BR>
&nbsp;&nbsp;MenuItem* item(GlyphIndex) const;<BR>
&nbsp;&nbsp;void select(GlyphIndex);<BR>
&nbsp;&nbsp;GlyphIndex selected() const;<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 9.5: WidgetKit menu operations, menu, and menu item protocols.
<BR>
<A NAME="PAGE57"></A>
&nbsp;&nbsp;</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
9- 7
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
Glyph* hslider(Adjustable*) const;<BR>
&nbsp;&nbsp;Glyph* hscroll_bar(Adjustable*) const;<BR>
&nbsp;&nbsp;Glyph* vslider(Adjustable*) const;<BR>
&nbsp;&nbsp;Glyph* vscroll_bar(Adjustable*) const;<BR>
&nbsp;&nbsp;Glyph* panner(Adjustable*, Adjustable*) const;<BR>
&nbsp;&nbsp;Stepper* enlarger(Adjustable*) const;<BR>
&nbsp;&nbsp;Stepper* reducer(Adjustabel*) const;<BR>
&nbsp;&nbsp;Stepper* up_mover(Adjustable*) const;<BR>
&nbsp;&nbsp;Stepper* down_mover(Adjustable*) const;<BR>
&nbsp;&nbsp;Stepper* left_mover(Adjustable*) const;<BR>
&nbsp;&nbsp;Stepper* right_mover(Adjustable*) const;<BR>
&nbsp;&nbsp;Glyph* slider_look(DimensionName, Adjustable*) const;<BR>
&nbsp;&nbsp;Glyph* scroll_bar_look(DimensionName, Adjustable*) const;<BR>
&nbsp;&nbsp;Glyph* panner_look(Adjustable*, Adjustable*) const;<BR>
&nbsp;&nbsp;Glyph* enlarger_look(TelltaleState*);<BR>
&nbsp;&nbsp;Glyph* reducer_look(TelltaleState*);<BR>
&nbsp;&nbsp;Glyph* up_mover_look(TelltaleState*);<BR>
&nbsp;&nbsp;Glyph* down_mover_look(TelltaleState*);<BR>
&nbsp;&nbsp;Glyph* left_mover_look(TelltaleState*);<BR>
&nbsp;&nbsp;Glyph* right_mover_look(TelltaleState*);<BR>
&nbsp;&nbsp;Figure 9.6: WidgetKit adjuster operations
<BR>
<A NAME="PAGE58"></A>
</FONT>
<FONT SIZE=9>
<!-- /Times-Bold -->
<B>Chapter 10<BR>
DialogKit<BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Whereas WidgetKit provides operations for creating common look-and-feel<BR>
components such as scrollbars, menus, and buttons, DialogKit is creates<BR>
higher-level dialog objects. The current implementation of DialogKit provides<BR>
only field editors and file choosers, but in the future this kit will provide<BR>
operations for creating confirmers, quit dialogs, and information messages. Figure<BR>
10.1 shows the operations provided by DialogKit.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>10.1 Field editor<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Many application need simple editors for entering or browsing data. A field editor<BR>
is suitable for incorporating into other components, such as a dialog box. Figure<BR>
10.2 shows the field editor class interface.<BR>
&nbsp;&nbsp;Clicking inside the editor (or calling FieldEditor::edit) initiates an edit.<BR>
Subsequent keyboard events, regardless of the pointer location, are interpreted as<BR>
editing operations on the text. Clicking outside the editor terminates the editing.<BR>
&nbsp;&nbsp;Text is selected with the pointer or with the keyboard. A single click of the left<BR>
button selects a new insertion point between characters. Dragging across the text<BR>
selects a range of characters. A set of control characters is mapped into common<BR>
editing operations. A character not specifically associated with commands is<BR>
inserted in place of the current selection, the replaced text is discarded, and<BR>
the selection becomes an insertion point following the inserted character. The<BR>
commands defined are:<BR>
&nbsp;&nbsp;character-left (^B)<BR>
&nbsp;&nbsp;character-right (^F)<BR>
&nbsp;&nbsp;beginning-of-text (^A)<BR>
&nbsp;&nbsp;end-of-text (^E)<BR>
&nbsp;&nbsp;erase (^H or DEL)<BR>
&nbsp;&nbsp;delete (^D)<BR>
&nbsp;&nbsp;select-all (^U)<BR>
&nbsp;&nbsp;select-word(^W)<BR>
Strings that are too long to fit into the editor can be scrolled horizontally. Clicking<BR>
the middle button inside the editor initiates #grab-scrollingº. While the button is<BR>
down the editor scrolls the text to follow the pointer, giving the appearance that<BR>
the user is dragging the text. Clicking the right button engages #rate-scrollingº, a<BR>
joy-stick-like scrolling interface in which the scrolling rate increases as the user<BR>
drags the pointer away from the initial click location.<BR>
&nbsp;&nbsp;The field editor constructor is passed a sample string, used to compute its<BR><BR>
&nbsp;&nbsp;10- 
<BR>
<A NAME="PAGE59"></A>
natural size, a style for customization, and a field editor action to execute when<BR>
editing returns. Editing normally completes when a carriage return or tab is<BR>
entered; abnormally when an escape character is entered.<BR>
&nbsp;&nbsp;FieldEditor::field sets the contents of the string being edited. FieldEditor::select<BR>
sets the insertion point or subrange within the edit string. FieldEditor::edit<BR>
initiates an edit. Specifying a string and selection range is short-hand for first<BR>
calling FieldEditor::field and FieldEditor::select. FieldEditor::text returns the<BR>
current value of the string being edited. The caller must copy the string to save<BR>
the contents, as it will be modified by a subsequent edit.<BR><BR><BR><BR><BR>
&nbsp;&nbsp;10- 2
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
interface DialogKit {<BR>
&nbsp;&nbsp;static DialogKit* instance();<BR>
&nbsp;&nbsp;FieldEditor* field_editor(<BR>
&nbsp;&nbsp;const String& sample, Style*, FieldEditorAction* = nil<BR>
&nbsp;&nbsp;) const;<BR>
&nbsp;&nbsp;FileChooser* file_chooser(<BR>
&nbsp;&nbsp;constString& dir, Style*, FileChooserAction* = nil<BR>
&nbsp;&nbsp;) const;<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 10.1: DialogKit operations
&nbsp;&nbsp; 
&nbsp;&nbsp;<BR><BR><BR><BR><BR>
&nbsp;&nbsp;interface FieldEditorAction Resource {<BR>
&nbsp;&nbsp;void execute(FieldEditor*, boolean accept);<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;interface FieldEditorCallback(T) : FieldEditorAction {<BR>
&nbsp;&nbsp;FieldEditorCallback(T)(T*, void (T::*)(FieldEditor*, boolean accept));<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;interface FieldEditor : InputHandler {<BR>
&nbsp;&nbsp;FieldEditor(const char* sample, Style*, FieldEditorAction* = nil);<BR>
&nbsp;&nbsp;FieldEditor(const String& sample, Style*, FieldEditorAction* = nil);<BR>
&nbsp;&nbsp;void field(const char*);<BR>
&nbsp;&nbsp;void field(const String&);<BR>
&nbsp;&nbsp;void select(int pos);<BR>
&nbsp;&nbsp;void select(int left, int right);<BR>
&nbsp;&nbsp;void edit();<BR>
&nbsp;&nbsp;void edit(const char*, int left, int right);<BR>
&nbsp;&nbsp;void edit(const String&, int left, int right);<BR>
&nbsp;&nbsp;const char* text() const;<BR>
&nbsp;&nbsp;void text(String&) const;<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 10.2: Field editor class interface.
<BR>
<A NAME="PAGE60"></A>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>10.2 Dialog<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
A dialog is an object that can be posted temporarily and grabs input until it is<BR>
dismissed. Figure 10.3 shows the Dialog protocol. Dialog::post_for creates a<BR>
transient window for the dialog and aligns over the given window using the given<BR>
x and y alignment. The default is for the dialog to be centered over the window.<BR>
&nbsp;&nbsp;Dialog::post_at creates a top-level window aligned around the given position.<BR>
Dialog::run blocks until Dialog::dismiss is called, and Dialog::run returns the<BR>
value of the parameter that is passed to Dialog::dismiss.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>10.3 FileChooser<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
A file chooser is a dialog subclass that allows the user to select a file in a directory<BR>
and returns the file name. Figure 10.4 shows the FileChooser protocol.<BR><BR><BR><BR><BR>
&nbsp;&nbsp;10- 3
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
interface DIalog : InputHandler {<BR>
&nbsp;&nbsp;Dialog(Glyph*, Style*);<BR>
&nbsp;&nbsp;boolean post_for(Window*, float = 0.5, float = 0.5);<BR>
&nbsp;&nbsp;boolean post_at(Coord x, Coord y, float = 0.5, float = 0.5);<BR>
&nbsp;&nbsp;boolean run();<BR>
&nbsp;&nbsp;void dismiss(boolean accept);<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 10.3: Dialog protocol
&nbsp;&nbsp; 
&nbsp;&nbsp;<BR><BR><BR><BR><BR>
&nbsp;&nbsp;interface FileChooserAction : Resource {<BR>
&nbsp;&nbsp;void execute(FileChooser*, boolean accept);<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;interface FileChooserCallback(T) : FileChooserAction {<BR>
&nbsp;&nbsp;FileChooserCallback(T)(T*, void (T::*)(FileChooser*, boolean accept));<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;interface FileChooser : Dialog {<BR>
&nbsp;&nbsp;const String* selected() const;<BR>
&nbsp;&nbsp;void reread();<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 10.4: FileChooser protocol
<BR>
<A NAME="PAGE61"></A>
</FONT>
<FONT SIZE=9>
<!-- /Times-Bold -->
<B>Chapter 11<BR>
LayoutKit<BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Composite glyphs usually manage the physical layout of their children.<BR>
LayoutKit provides operations for creating objects that are useful in managing the<BR>
arrangement of one or more glyphs. The LayoutKit objects are modelled after the<BR>
Knuth's TeX document processing system.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>11.1 Boxes<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
A box is a polyglyph that uses a layout object to arrange its components. A layout<BR>
object is not a glyph, but helps a glyph manage the requests and allocations of<BR>
component glyphs. Figure 11.1 shows the Layout protocol and the LayoutKit<BR>
operations that create boxes.<BR>
&nbsp;&nbsp;Layout::request is given an array of requisitions for the individual components<BR>
and computes a single requisition for the result. Layout::allocate is given the<BR>
requisitions of the components and the overall allocation, returning the allocations<BR>
of the individual components.<BR>
&nbsp;&nbsp;A box can be constructed either with a list of up to 10 initial glyph components,<BR>
or an initial size estimate on the number of components. The size is not a<BR>
maximum, but can avoid growing the list dynamically.<BR>
&nbsp;&nbsp;LayoutKit::hbox returns a box that tiles its components in the X<BR>
dimension left-to-right and aligns the component origins in the Y dimension.<BR>
LayoutKit::vbox returns a box that tiles top-to-bottom and aligns in the X<BR>
dimension. LayoutKit::overlay aligns in both the X and Y dimensions, drawing<BR>
the components in back-to-front order.<BR>
&nbsp;&nbsp;LayoutKit::hbox returns a box with its X origin at the left side of the<BR>
box; LayoutKit::vbox returns a box with its Y origin at the top of the box.<BR>
Sometimes it is more convenient to have the origin correspond to the origin<BR>
of the first component. For example, a column of text might want to have<BR>
its Y origin correspond to the base line of the first line of text. When the<BR>
aligment should correspond to the first component's alignment, one can use<BR>
LayoutKit::hbox_first_aligned or LayoutKit::vbox_first_aligned.<BR>
&nbsp;&nbsp;A <!-- /Times-Italic -->
<I>deck </I><!-- /Times-Roman -->
is a polyglyph similar in some ways to an overlay box. However,<BR>
instead of overlaying its components, a deck is a polyglyph where only one of the<BR>
components is visible at any time. Figure 11.2 shows the deck protocol and the<BR>
LayoutKit operations to create decks.<BR>
&nbsp;&nbsp;Deck::flip_to sets which component should currently be visible; Deck::card<BR>
returns the current top. The natural size of a deck is the maximum size of the<BR>
natural sizes of its components. A deck can be stretched to be as large as its<BR>
largest fully-stretched component.<BR><BR>
&nbsp;&nbsp;11- 
<BR>
<A NAME="PAGE62"></A>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>11.2 Glue<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Boxes stretch or shrink their components to fit the available space. However,<BR>
many components are rigid. For example, characters in text typically do not<BR>
stretch or shrink. Instead, we prefer to stretch or shrink the white space between<BR>
words. In TeX, this flexible white space is referred to as #glueº.<BR>
&nbsp;&nbsp;LayoutKit provides the set of operations to create glue object shown in Figure<BR>
11.3. LayoutKit::glue is the most general operation. It can either be passed a<BR>
specific dimension, natural size, stretchability, shrinkability, and alignment, or it<BR>
can be passed a complete requisition.<BR>
&nbsp;&nbsp;LayoutKit::hglue and LayoutKit::vglue can create glue that is horizontally or<BR>
vertically stretchable, respectively. The requirement in the minor dimension is<BR>
undefined. If no parameters are passed to LayoutKit::hglue or vglue, then a<BR>
natural size of zero is assumed. If no stretchability is specified, then the glue is<BR>
&nbsp;&nbsp;11- 2
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
interface Layout {<BR>
&nbsp;&nbsp;void request(GlyphIndex count, const Requisition*, Requisition& result);<BR>
&nbsp;&nbsp;void allocate(<BR>
&nbsp;&nbsp;const Allocation& given, GlyphIndex count, const Requisition*,<BR>
&nbsp;&nbsp;Allocation* result<BR>
&nbsp;&nbsp;);<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;PolyGlyph* box(Layout*, GlyphIndex size = 10) const;<BR>
&nbsp;&nbsp;PolyGlyph* hbox(GlyphIndex size) const;<BR>
&nbsp;&nbsp;PolyGlyph* hbox(<BR>
&nbsp;&nbsp;Glyph* = nil, Glyph* = nil, Glyph* = nil, Glyph* = nil, Glyph* = nil,<BR>
&nbsp;&nbsp;Glyph* = nil, Glyph* = nil, Glyph* = nil, Glyph* = nil, Glyph* = nil<BR>
&nbsp;&nbsp;) const;<BR>
&nbsp;&nbsp;PolyGlyph* vbox(GlyphIndex size) const;<BR>
&nbsp;&nbsp;PolyGlyph* vbox(<BR>
&nbsp;&nbsp;Glyph* = nil, Glyph* = nil, Glyph* = nil, Glyph* = nil, Glyph* = nil,<BR>
&nbsp;&nbsp;Glyph* = nil, Glyph* = nil, Glyph* = nil, Glyph* = nil, Glyph* = nil<BR>
&nbsp;&nbsp;) const;<BR>
&nbsp;&nbsp;PolyGlyph* hbox_first_aligned(GlyphIndex size) const;<BR>
&nbsp;&nbsp;PolyGlyph* hbox_first_aligned(<BR>
&nbsp;&nbsp;Glyph* = nil, Glyph* = nil, Glyph* = nil, Glyph* = nil, Glyph* = nil,<BR>
&nbsp;&nbsp;Glyph* = nil, Glyph* = nil, Glyph* = nil, Glyph* = nil, Glyph* = nil<BR>
&nbsp;&nbsp;) const;<BR>
&nbsp;&nbsp;PolyGlyph* vbox_first_aligned(GlyphIndex size) const;<BR>
&nbsp;&nbsp;PolyGlyph* vbox_first_aligned(<BR>
&nbsp;&nbsp;Glyph* = nil, Glyph* = nil, Glyph* = nil, Glyph* = nil, Glyph* = nil,<BR>
&nbsp;&nbsp;Glyph* = nil, Glyph* = nil, Glyph* = nil, Glyph* = nil, Glyph* = nil<BR>
&nbsp;&nbsp;) const;<BR>
&nbsp;&nbsp;PolyGlyph* overlay(<BR>
&nbsp;&nbsp;Glyph* = nil, Glyph* = nil, Glyph* = nil, Glyph* = nil, Glyph* = nil,<BR>
&nbsp;&nbsp;Glyph* = nil, Glyph* = nil, Glyph* = nil, Glyph* = nil, Glyph* = nil<BR>
&nbsp;&nbsp;) const;<BR>
&nbsp;&nbsp;Figure 11.1: Layout protocol and LayoutKit box operations
<BR>
<A NAME="PAGE63"></A>
</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
assumed to be infinitely stretchable.<BR>
&nbsp;&nbsp;LayoutKit::hspace and LayoutKit::vspace create glue with a given size that is<BR>
rigid. LayoutKit::shape_of returns glue that has the same requisition as another<BR>
glyph. LayoutKit::shape_of_xy returns glue that takes its X requirement from one<BR>
glyph and its Y requirement from another glyph.<BR>
&nbsp;&nbsp;LayoutKit::spaces returns glue that correspond to a given number of spaces in<BR><BR><BR><BR><BR>
&nbsp;&nbsp;11- 3
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
interface Deck : PolyGlyph {<BR>
&nbsp;&nbsp;GlyphIndex card() const;<BR>
&nbsp;&nbsp;void flip_to(GlyphIndex);<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Deck* deck(GlyphIndex size) const;<BR>
&nbsp;&nbsp;Deck* deck(<BR>
&nbsp;&nbsp;Glyph* = nil, Glyph* = nil, Glyph* = nil, Glyph* = nil, Glyph* = nil,<BR>
&nbsp;&nbsp;Glyph* = nil, Glyph* = nil, Glyph* = nil, Glyph* = nil, Glyph* = nil<BR>
&nbsp;&nbsp;) const;<BR>
&nbsp;&nbsp;Figure 11.2: Deck protocol and LayoutKit operations
&nbsp;&nbsp; 
&nbsp;&nbsp;<BR><BR><BR><BR><BR>
&nbsp;&nbsp;Glyph* glue(<BR>
<CENTER>
DimensionName, Coord natural, Coord stretch, Coord shrink, float alignment<BR>
</CENTER>
&nbsp;&nbsp;) const;<BR>
&nbsp;&nbsp;Glyph* glue(const Requisition&) const;<BR>
&nbsp;&nbsp;Glyph* hglue() const;<BR>
&nbsp;&nbsp;Glyph* hglue(Coord natural) const;<BR>
&nbsp;&nbsp;Glyph* hglue(Coord natural, Coord stretch, Coord shrink) const;<BR>
<CENTER>
Glyph* hglue(Coord natural, Coord stretch, Coord shrink, float alignment) const;<BR>
</CENTER>
&nbsp;&nbsp;Glyph* vglue() const;<BR>
&nbsp;&nbsp;Glyph* vglue(Coord natural);<BR>
&nbsp;&nbsp;Glyph* vglue(Coord natural, Coord stretch, Coord shrink) const;<BR>
<CENTER>
Glyph* vglue(Coord natural, Coord stretch, Coord shrink, float alignment) const;<BR>
</CENTER>
&nbsp;&nbsp;Glyph* hspace(Coord) const;<BR>
&nbsp;&nbsp;Glyph* vspace(Coord) const;<BR>
&nbsp;&nbsp;Glyph* shape_of(Glyph*) const;<BR>
&nbsp;&nbsp;Glyph* shape_of_xy(Glyph*, Glyph*) const;<BR>
&nbsp;&nbsp;Glyph* spaces(int count, Coord each, const Font*, const Color*) const;<BR>
&nbsp;&nbsp;Glyph* strut(<BR>
&nbsp;&nbsp;const Font*, Coord natural = 0, Coord stretch = 0, Coord shrink = 0<BR>
&nbsp;&nbsp;) const;<BR>
&nbsp;&nbsp;Glyph* hstrut(<BR>
&nbsp;&nbsp;Coord right_bearing, Coord left_bearing = 0,<BR>
&nbsp;&nbsp;Coord natural = 0, Coord stretch = 0, Coord shrink = 0<BR>
&nbsp;&nbsp;) const;<BR>
&nbsp;&nbsp;Glyph* vstrut(<BR>
&nbsp;&nbsp;Coord ascent, Coord descent = 0,<BR>
&nbsp;&nbsp;Coord natural = 0, Coord stretch = 0, Coord shrink = 0<BR>
&nbsp;&nbsp;) const;<BR>
&nbsp;&nbsp;Figure 11.3: LayoutKit operations for creating spacing glyphs
<BR>
<A NAME="PAGE64"></A>
</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
the current font. Unlike other glue objects, which despite being generally referred<BR>
to as #white spaceº do not actually have an appearance, spaces are drawn in the<BR>
given color.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>11.3 Alignment<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
In addition to laying out a collection of glyphs, it is often desirable to modify the<BR>
positioning of a single glyph. LayoutKit provides operations to adjust the layout<BR>
of a glyph. These operations return a monoglyph.<BR>
&nbsp;&nbsp;Figure 11.4 shows the operations that affect the requisition of a glyph.<BR>
LayoutKit::center , center_dimension, hcenter, and vcenter change the origin of a<BR>
glyph as it appears in a requisition. When the glyph body is allocated, it is given<BR>
the origin it requested. Thus, the name #centerº is somewhat misleading as these<BR>
monoglyphs merely return a glyph that asks to be centered at a particular position,<BR>
they do not actually change the origin themselves.<BR>
&nbsp;&nbsp;LayoutKit::fixed, fixed_dimension, hfixed, and vfixed change a glyph to appear<BR>
rigid even if it is flexible. Fixed monoglyphs are ideal for specifying sizes<BR>
that are otherwise undefined, such as the initial height of a file chooser. The<BR>
inverse functionality±making a glyph flexible that may be rigid±is provided by<BR>
the LayoutKit::flexible, flexible_dimension, hflexible, and vflexible operations.<BR>
The LayoutKit::natural, natural_dimension, hnatural, and vnatural operations are<BR><BR>
&nbsp;&nbsp;11- 4
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
MonoGlyph* center(Glyph*, float x = 0.5, float y = 0.5) const;<BR>
&nbsp;&nbsp;MonoGlyph* center_dimension(Glyph*, DimensionName, float align) const;<BR>
&nbsp;&nbsp;MonoGlyph* hcenter(Glyph*, float x = 0.5) const;<BR>
&nbsp;&nbsp;MonoGlyph* vcenter(Glyph*, float y = 0.5) const;<BR>
&nbsp;&nbsp;MonoGlyph* fixed(Glyph*, Coord x, Coord y) const;<BR>
&nbsp;&nbsp;MonoGlyph* fixed_dimension(Glyph*, DimensionName, Coord) const;<BR>
&nbsp;&nbsp;MonoGlyph* hfixed(Glyph*, Coord x) const;<BR>
&nbsp;&nbsp;MonoGlyph* vfixed(Glyph*, Coord y) const;<BR>
&nbsp;&nbsp;MonoGlyph* flexible(Glyph*, Coord stretch = fil, Coord shrink = fil) const;<BR>
&nbsp;&nbsp;MonoGlyph* flexible_dimension(<BR>
&nbsp;&nbsp;Glyph*, DimensionName, Coord stretch = fil, Coord shrink = fil<BR>
&nbsp;&nbsp;) const;<BR>
&nbsp;&nbsp;MonoGlyph* hflexible(<BR>
&nbsp;&nbsp;Glyph*, Coord stretch = fil, Coord shrink = fil<BR>
&nbsp;&nbsp;) const;<BR>
&nbsp;&nbsp;MonoGlyph* vflexible(<BR>
&nbsp;&nbsp;Glyph*, Coord stretch = fil, Coord shrink = fil<BR>
&nbsp;&nbsp;) const;<BR>
&nbsp;&nbsp;MonoGlyph* natural(Glyph*, Coord x, Coord y) const;<BR>
&nbsp;&nbsp;MonoGlyph* natural_dimension(Glyph*, DimensionName, Coord) const;<BR>
&nbsp;&nbsp;MonoGlyph* hnatural(Glyph*, Coord) const;<BR>
&nbsp;&nbsp;MonoGlyph* vnatural(Glyph*, Coord) const;<BR>
&nbsp;&nbsp;Figure 11.4: LayoutKit operations that adjust alignment
<BR>
<A NAME="PAGE65"></A>
</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
similar to the fixed operations in that they change the natural size, but they do not<BR>
affect the flexibility.<BR>
&nbsp;&nbsp;LayoutKit also provides a set of operations to put a margin around a glyph.<BR>
These operations are shown in Figure 11.5. LayoutKit::margin is overloaded to<BR>
specify a fixed margin around the entire glyph, distinct horizontal and vertical<BR>
margins, separate left, right, bottom, and top margins, or flexible margins on<BR>
each side. LayoutKit::hmargin specifies horizontal margins; LayoutKit::vmargin<BR>
specifies vertical margins. LayoutKit::lmargin, rmargin, bmargin, and tmargin<BR>
specify left, right, bottom, and top margins, respectively.<BR><BR><BR><BR><BR>
&nbsp;&nbsp;11- 5
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
MonoGlyph* margin(Glyph*, Coord) const;<BR>
&nbsp;&nbsp;MonoGlyph* margin(Glyph*, Coord hmargin, Coord vmargin) const;<BR>
&nbsp;&nbsp;MonoGlyph* margin(<BR>
&nbsp;&nbsp;Glyph*, Coord lmargin, Coord rmargin, Coord bmargin, Coord tmargin<BR>
&nbsp;&nbsp;) const;<BR>
&nbsp;&nbsp;MonoGlyph* margin(<BR>
&nbsp;&nbsp;Glyph*,<BR>
&nbsp;&nbsp;Coord lmargin, Coord lstretch, Coord lshrink,<BR>
&nbsp;&nbsp;Coord rmargin, Coord rstretch, Coord rshrink,<BR>
&nbsp;&nbsp;Coord bmargin, Coord bstretch, Coord bshrink,<BR>
&nbsp;&nbsp;Coord tmargin, Coord tstretch, Coord tshrink<BR>
&nbsp;&nbsp;) const;<BR>
&nbsp;&nbsp;MonoGlyph* hmargin(Glyph*, Coord) const;<BR>
&nbsp;&nbsp;MonoGlyph* hmargin(Glyph*, Coord lmargin, Coord rmargin) const;<BR>
&nbsp;&nbsp;MonoGlyph* hmargin(<BR>
&nbsp;&nbsp;Glyph*,<BR>
&nbsp;&nbsp;Coord lmargin, Coord lstretch, Coord lshrink,<BR>
&nbsp;&nbsp;Coord rmargin, Coord rstretch, Coord rshrink<BR>
&nbsp;&nbsp;) const;<BR>
&nbsp;&nbsp;MonoGlyph* vmargin(Glyph*, Coord) const;<BR>
&nbsp;&nbsp;MonoGlyph* vmargin(Glyph*, Coord lmargin, Coord rmargin) const;<BR>
&nbsp;&nbsp;MonoGlyph* vmargin(<BR>
&nbsp;&nbsp;Glyph*,<BR>
&nbsp;&nbsp;Coord bmargin, Coord bstretch, Coord bshrink,<BR>
&nbsp;&nbsp;Coord tmargin, Coord tstretch, Coord tshrink<BR>
&nbsp;&nbsp;) const;<BR>
&nbsp;&nbsp;MonoGlyph* lmargin(Glyph*, Coord) const;<BR>
&nbsp;&nbsp;MonoGlyph* lmargin(Glyph*, Coord nat, Coord stretch, Coord shrink) const;<BR>
&nbsp;&nbsp;MonoGlyph* rmargin(Glyph*, Coord) const;<BR>
&nbsp;&nbsp;MonoGlyph* rmargin(Glyph*, Coord nat, Coord stretch, Coord shrink) const;<BR>
&nbsp;&nbsp;MonoGlyph* bmargin(Glyph*, Coord) const;<BR>
&nbsp;&nbsp;MonoGlyph* bmargin(Glyph*, Coord nat, Coord stretch, Coord shrink) const;<BR>
&nbsp;&nbsp;MonoGlyph* tmargin(Glyph*, Coord) const;<BR>
&nbsp;&nbsp;MonoGlyph* tmargin(Glyph*, Coord nat, Coord stretch, Coord shrink) const;<BR>
&nbsp;&nbsp;Figure 11.5: LayoutKit margin operations
<BR>
<A NAME="PAGE66"></A>
</FONT>
<FONT SIZE=9>
<!-- /Times-Bold -->
<B>Chapter 12<BR>
DocumentKit<BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
In Chapter 11, we described the LayoutKit class, which provides operations<BR>
for creating layout objects. The DocumentKit class will provide operations<BR>
for creating document objects that use LayoutKit objects to produce formatted<BR>
documents. The DocumentKit class has not yet been implemented, so for now<BR>
we describe several objects that can be useful for building document editors in<BR>
conjunction with the LayoutKit objects.<BR>
&nbsp;&nbsp;A <!-- /Times-Italic -->
<I>discretionary </I><!-- /Times-Roman -->
can take on one of several appearances depending on whether a<BR>
break occurs on it. A common use of a discretionary is for white space in a line of<BR>
text, where the white space becomes zero-width glue if a break occurs on the<BR>
discretionary. The penalty associated with a discretionary defines the relative cost<BR>
of breaking. Currently, operations to create discretionaries are defined on the<BR>
LayoutKit.<BR>
&nbsp;&nbsp;An <!-- /Times-Italic -->
<I>lr-marker </I><!-- /Times-Roman -->
is a glyph that can mark a region of its body. The marking is<BR>
done by painting a color under the area or a color on top of the area (or both).<BR>
The region is a shape normally associated with text selections. The LRMarker<BR>
constructor takes two colors, either of which can be nil if the associated underlay<BR>
or overlay drawing is not desired. LRMarker::mark paints the given region. If y1<BR>
and y2 are the same, then the mark region is a single rectangle. Otherwise, the<BR>
region is defined as starting at (x1,y1) and filling a height of h1 to (x1,right()),<BR>
then filling (left(),y1+h1) to (right(),y2) and filling a height of h2 from (left(),y2)<BR>
to (x2,y2). LRMarker::unmark restores the area to its unmarked appearance. An<BR>
<!-- /Times-Italic -->
<I>xy-marker </I><!-- /Times-Roman -->
is simliar to an lr-marker, but it only paints a rectangular area. While<BR>
an lr-marker is most useful for selecting text, xy-markers are useful for selecting<BR>
an item in a list or table. Figure 12.1 shows the LRMarker and XYMarker class<BR>
interfaces.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>12.1 Compositions<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
A <!-- /Times-Italic -->
<I>composition </I><!-- /Times-Roman -->
is a glyph that uses a <!-- /Times-Italic -->
<I>compositor </I><!-- /Times-Roman -->
to determine suitable breaks<BR>
between groups of its components. Figure 12.2 shows the class interfaces for the<BR>
composition and its subclasses. The list of components is broken into sublists<BR>
that are put into separate composite glyphs and then inserted into the body.<BR>
The LRComposition subclass uses LayoutKit::hbox_first_aligned to create each<BR>
sublist, while the TBComposition subclass uses LayoutKit::vbox_first_aligned.<BR>
&nbsp;&nbsp;Compositions can be used to break paragraphs into lines, lines into columns,<BR>
or columns into pages. A document editor might create an lr-composition for<BR>
characters that puts the resulting hboxes for lines into a tb-composition, which in<BR>
turn puts the vboxes for columns into an lr-composition, which puts the resulting<BR><BR>
&nbsp;&nbsp;12- 
<BR>
<A NAME="PAGE67"></A>
lr-boxes for pages into a deck.<BR>
&nbsp;&nbsp;Compositions also can be used just as easily for arranging buttons in a box,<BR>
where one wants the buttons to ``wrap-around'' if there are too many to fit<BR>
horizontally. The code to do this could look as follows:<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
LRComposition* c = new LRComposition(<BR>
&nbsp;&nbsp;layout.vbox(), new SimpleCompositor, /* no separator */ nil, /* width */ 4*72.0<BR>
&nbsp;&nbsp;);<BR>
&nbsp;&nbsp;Discretionary* ok = layout.discretionary(0, nil, nil, nil, nil);<BR>
&nbsp;&nbsp;for (unsigned int i = 0; i < nbuttons; i++) {<BR>
&nbsp;&nbsp;c->append(button[i]);<BR>
&nbsp;&nbsp;c->append(ok);<BR>
&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;c->repair();<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
The composition constructor takes a body in which to insert sublists, a<BR>
compositor to determine where to break, a separator to be inserted at each break<BR>
(unless it is nil), the dimension to use, the width in which the sublists must fit,<BR>
and optionally the initial size of the list of components. The initial size is not<BR>
a maximum, but the list by default starts at a small size and is dynamically<BR>
reallocated as needed. For large lists, it can be more efficient to specify an<BR>
estimate of the list size. Composition::repair updates the composition to reflect<BR>
changes to its structure. Composition::item returns the index of the sublist (in<BR>
other words, the component of the body) containing the component specified by<BR>
the given index. For example, this function could be used to return the line that<BR>
contains a particular character. Composition::beginning_of returns the index of<BR>
the component that starts the sublist specified by the given item. For example,<BR>
this function could be used to return the character that starts a particular line.<BR>
Composition::end_of is like beginning_of except it returns the end of the sublist.<BR>
Composition::margin causes space to be left at the beginning and end of the<BR>
specified item in the body. For example, this function could be used to put<BR>
margins on a line of text. Composition::view guarantees that breaks are computed<BR>
&nbsp;&nbsp;12- 2
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
interface LRMarker : MonoGlyph {<BR>
&nbsp;&nbsp;LRMarker(Glyph*, Color* overlay, Color* underlay);<BR>
&nbsp;&nbsp;void mark(<BR>
&nbsp;&nbsp;Coord left, Coord right, Coord x1, Coord y1,<BR>
&nbsp;&nbsp;Coord h1, Coord x2, Coord y2, Coord h2<BR>
&nbsp;&nbsp;);<BR>
&nbsp;&nbsp;void unmark();<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;interface XYMarker : MonoGlyph {<BR>
&nbsp;&nbsp;XYMarker(Glyph*, Color* overlay, Color* underlay);<BR>
&nbsp;&nbsp;void mark(Coord left, Coord bottom, Coord right, Coord top);<BR>
&nbsp;&nbsp;void unmark();<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 12.1: LRMarker and XYMarker protocols
<BR>
<A NAME="PAGE68"></A>
</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
for the components between indices <!-- /Times-Italic -->
<I>first </I><!-- /Times-Roman -->
and <!-- /Times-Italic -->
<I>last </I><!-- /Times-Roman -->
inclusively. By restricting<BR>
the viewing area, this operation can eliminate the computation of breaks for<BR>
components that are not visible.<BR>
&nbsp;&nbsp;A compositor computes the breaks based on assessing the penalty for a possible<BR>
breaks. Three subclasses are provided that use different levels of sophistication in<BR>
determining breaks. An <!-- /Times-Italic -->
<I>array-compositor </I><!-- /Times-Roman -->
positions breaks every N elements,<BR>
where N is specified in the constructor. A <!-- /Times-Italic -->
<I>simple-compositor </I><!-- /Times-Roman -->
finds a simple<BR>
set of breaks quickly. It is analogous to a line-at-a-time text formatter. A<BR>
<!-- /Times-Italic -->
<I>TeX-compositor </I><!-- /Times-Roman -->
finds breaks using Knuth's TeX algorithm.<BR>
&nbsp;&nbsp;Figure 12.3 shows the interfaces to the compositor classes.<BR>
Compositor::compose uses the natural, stretch, shrink, penalty, and span<BR>
information for each component as input parameters. The return value is the<BR>
number of breaks found. The </FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
breaks </FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
array contains the positions of the breaks;<BR>
that is, </FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
break[i] </FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
is the index of the component where the <!-- /Times-Italic -->
<I>ith </I><!-- /Times-Roman -->
break occurs.<BR><BR><BR><BR><BR>
&nbsp;&nbsp;12- 3
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
interface Composition : MonoGlyph {<BR>
&nbsp;&nbsp;Composition(<BR>
&nbsp;&nbsp;Glyph*, Compositor*, Glyph* separator, DimensionName,<BR>
&nbsp;&nbsp;Coord width, GlyphIndex size<BR>
&nbsp;&nbsp;);<BR>
&nbsp;&nbsp;void repair();<BR>
&nbsp;&nbsp;GlyphIndex item(GlyphIndex);<BR>
&nbsp;&nbsp;lyphIndex beginning_of(GlyphIndex);<BR>
&nbsp;&nbsp;GlyphIndex end_of(GlyphIndex);<BR>
&nbsp;&nbsp;void margin(GlyphIndex, Coord begin, Coord end);<BR>
&nbsp;&nbsp;void view(GlyphIndex first, GlyphIndex last);<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;interface LRComposition : Composition {<BR>
&nbsp;&nbsp;LRComposition(<BR>
&nbsp;&nbsp;Glyph*, Compositor*, Glyph* sep, Coord, GlyphIndex = 10<BR>
&nbsp;&nbsp;);<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;interface TBComposition : Composition {<BR>
&nbsp;&nbsp;TBComposition(<BR>
&nbsp;&nbsp;Glyph*, Compositor*, Glyph* sep, Coord, GlyphIndex = 10<BR>
&nbsp;&nbsp;);<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 12.2: Composition classes
<BR>
<A NAME="PAGE69"></A>
</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
See iv/src/examples/preview.<BR><BR><BR><BR><BR>
&nbsp;&nbsp;12- 4
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
interface Compositor {<BR>
&nbsp;&nbsp;virtual int compose(<BR>
&nbsp;&nbsp;Coord* natural, Coord* stretch, Coord* shrink,<BR>
&nbsp;&nbsp;int* penalties, int component_count,<BR>
&nbsp;&nbsp;Coord* spans, int span_count,<BR>
&nbsp;&nbsp;int* breaks, int break_count<BR>
&nbsp;&nbsp;);<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;interface ArrayCompositor : Compositor {<BR>
&nbsp;&nbsp;ArrayCompositor(int N);<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;interface SimpleCompositor : Compositor {<BR>
&nbsp;&nbsp;SimpleCompositor();<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;interface TeXCompositor : Compositor {<BR>
&nbsp;&nbsp;TeXCompositor(int penalty);<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure 12.3: Compositor classes
<BR>
<A NAME="PAGE70"></A>
</FONT>
<FONT SIZE=9>
<!-- /Times-Bold -->
<B>Appendix A<BR>
Operating System Interface<BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
This appendix describes the classes that abstract operating system services. These<BR>
classes do not yet cover the entire range of operating system operations, but they<BR>
offer higher-level abstractions in some cases, relief from name space concerns in<BR>
other cases, and greater application portability.<BR>
&nbsp;&nbsp;The classes are presented below in alphabetical order. A <!-- /Times-Italic -->
<I>directory </I><!-- /Times-Roman -->
is a list<BR>
of files or other directories. A file is a list of bytes. Both directories and<BR>
files are accessed by a string name. A <!-- /Times-Italic -->
<I>list </I><!-- /Times-Roman -->
is an ordered sequence of objects,<BR>
parameterized by the element type. The math class provides an interface to<BR>
common mathematical operations on concrete types (e.g., ints and floats). The<BR>
memory class provides operations on variable-length arrays of bytes. A <!-- /Times-Italic -->
<I>string </I><!-- /Times-Roman -->
is a<BR>
variable-length list of characters. A <!-- /Times-Italic -->
<I>table </I><!-- /Times-Roman -->
is an associative map from a key type to<BR>
a data type.<BR>
&nbsp;&nbsp;List and table are generic classes, parameterized by other types. Because<BR>
few C++ implementations currently support a generic mechanism (though the<BR>
language defines a template construct), it is necessary to define list and table<BR>
classes using preprocessor macros and must be instantiated explicitly.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>A.1 Directory<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Figure A.1 shows the directory class interface. The static member functions<BR>
Directory::current and Directory::open return a pointer to a Directory.<BR>
Directory::current looks in the default directory for the application context,<BR>
Directory::open tries to find the directory with the given name. If the name cannot<BR>
be found or access is denied to the directory, Director::open returns nil.<BR><BR><BR><BR><BR>
&nbsp;&nbsp;A- 1
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
interface Directory {<BR>
&nbsp;&nbsp;static Directory* current();<BR>
&nbsp;&nbsp;static Directory* open(const String&);<BR>
&nbsp;&nbsp;int count() const;<BR>
&nbsp;&nbsp;const char* name(int i) const;<BR>
&nbsp;&nbsp;int index(const char*) const;<BR>
&nbsp;&nbsp;boolean is_directory(int index) const;<BR>
&nbsp;&nbsp;void close();<BR>
&nbsp;&nbsp;static String* canonical(const String&);<BR>
&nbsp;&nbsp;static boolean match(const String& name, const String& pattern);<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure A.1: Directory class interface.
<BR>
<A NAME="PAGE71"></A>
&nbsp;&nbsp;</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Directory::count returns the number of entries (files and directories), including<BR>
any special system entries such as #.º and #..º on Unix. Directory::name returns<BR>
the name of the specified entry. Directory::index returns the index of the entry<BR>
that matches the given name or -1 if no match is found. Directory::close discards<BR>
the information associated with the directory.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>A.2 File<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Figure A.2 shows the file class interface and subclasses for input handling. The<BR>
base class File is abstract and defines no data access functions. Currently, only<BR>
input files are implemented. File::name returns the string name of the file.<BR>
File::length returns the number of bytes in the file. File::close releases any<BR>
information associated with the file.<BR>
&nbsp;&nbsp;File::limit sets an upper bound on the size of a buffer to allocate for file storage.<BR>
By default, a file attempts to allocate contiguous storage for its entire contents.<BR>
This approach can allow for simpler application code and can be implemented<BR>
very efficiently on systems with memory-mapped files.<BR>
&nbsp;&nbsp;The contents of an input file can be accessed but not modified. InputFile::open<BR>
returns nil if the named file cannot be found or is not readable. InputFile::read<BR>
allocates a data area for the file contents, sets the start parameter to the beginning<BR>
of the area, and returns the length of the area. If no storage limit has been<BR>
specified and the file is on disk (as opposed to a terminal or pipe), then read will<BR>
return the entire file.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>A.3 List<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Figure A.3 shows the list generic class interfaces. The implementation of lists<BR>
uses a dynamic array with an insertion gap, meaning that large lists are very<BR><BR><BR><BR><BR>
&nbsp;&nbsp;A- 2
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
interface File {<BR>
&nbsp;&nbsp;const char* name() const;<BR>
&nbsp;&nbsp;long length() const;<BR>
&nbsp;&nbsp;void close();<BR>
&nbsp;&nbsp;void limit(unsigned int buffersize);<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;interface InputFile : File {<BR>
&nbsp;&nbsp;static InputFile* open(const char* name);<BR>
&nbsp;&nbsp;int read(const char*& start);<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure A.2: InputFile protocols.
<BR>
<A NAME="PAGE72"></A>
</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
space-efficient. The time efficiency depends on the distribution of insertions±if<BR>
the insertion position moves frequently, the list will do excessive copying.<BR>
&nbsp;&nbsp;The list constructor takes an optional initial size for the dynamic array. For lists<BR>
that are known to be large, specifying an initial size avoids the cost of growing the<BR>
array dynamically. List::count returns the number of elements in the list (not the<BR>
size of the array). List::item returns the indexed item.<BR>
&nbsp;&nbsp;List::prepend adds an item at the beginning of the list, List::append at the end,<BR>
and List::insert before an indexed item. List::remove deletes the item specified by<BR>
the given index. List::remove_all deletes all the items in the list.<BR>
&nbsp;&nbsp;ListItr is a class for iterating through the elements of a list, parameterized<BR>
explicitly by the list type and implicitly by the element type. The constructor is<BR>
given the target list. ListItr::more returns true if additional elements are available<BR>
in the iteration. ListItr::cur returns the current iteration's item. ListItr::cur_ref<BR>
returns a reference to the item. ListItr::remove_cur deletes the current item<BR>
from the list. ListItr::next moves the iteration to the next item in the list. No<BR><BR>
&nbsp;&nbsp;A- 3
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
interface List(T) {<BR>
&nbsp;&nbsp;List(T)(long initial_size = 0);<BR>
&nbsp;&nbsp;long count() const;<BR>
&nbsp;&nbsp;T item(long index) const;<BR>
&nbsp;&nbsp;T& item_ref(long index) const;<BR>
&nbsp;&nbsp;void prepend(const T&);<BR>
&nbsp;&nbsp;void append(const T&);<BR>
&nbsp;&nbsp;void insert(long index, const T&);<BR>
&nbsp;&nbsp;void remove(long index);<BR>
&nbsp;&nbsp;void remove_all();<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;interface ListItr(ListType) {<BR>
&nbsp;&nbsp;ListItr(ListType))(const ListType&);<BR>
&nbsp;&nbsp;boolean more() const;<BR>
&nbsp;&nbsp;T cur() const;<BR>
&nbsp;&nbsp;T& cur_ref() const;<BR>
&nbsp;&nbsp;void next();<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;interface ListUpdater(ListType) {<BR>
&nbsp;&nbsp;ListUpdater(ListType)(ListType&);<BR>
&nbsp;&nbsp;boolean more() const;<BR>
&nbsp;&nbsp;T cur() const;<BR>
&nbsp;&nbsp;T& cur_ref() const;<BR>
&nbsp;&nbsp;void remove_cur();<BR>
&nbsp;&nbsp;void next();<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure A.3: List and iterator class interfaces.
<BR>
<A NAME="PAGE73"></A>
</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
modifications should be made to the list during an iteration (except in the last<BR>
step), as this may cause unexpected or erroneous results.<BR>
&nbsp;&nbsp;As an example, consider a list of pointers to glyphs. We could declare such a<BR>
list in a header or source file as follows:<BR>
&nbsp;&nbsp;declarePtrList(GlyphList,Glyph)<BR>
Only one source file may contain the expansion of the implementation:<BR>
&nbsp;&nbsp;implementPtrList(GlyphList,Glyph)<BR>
A loop to iterate over all the glyphs in a list could be written as follows:<BR>
&nbsp;&nbsp;for (ListItr(GlyphList) i(list); i.more(); i.next()) {<BR>
&nbsp;&nbsp;Glyph* g = i.cur();<BR>
&nbsp;&nbsp;// do something with g<BR>
&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;A list makes no assumptions about its element type. In particular, destroying a<BR>
list of pointers will not destroy the objects that are the targets of the pointers.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>A.4 Math<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Figure A.4 shows the math class interface. One cannot create a #math objectº; all<BR>
the member functions are static. Math::min and Math::max return the minimum<BR>
and maximum of two or four numbers, respectively. For the sake of brevity only<BR>
the floating point definitions are shown, but Math::min and Math::max are also<BR>
defined for ints, longs, unsigned ints, unsigned longs, and doubles.<BR>
&nbsp;&nbsp;Math::abs returns the absolute value of a number. Math::round returns the<BR>
integer nearest to a floating point value. Math::equal compares two floating point<BR>
numbers and returns whether they are within a given epsilon (the third parameter)<BR>
of each other.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>A.5 Memory<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Figure A.5 shows the memory class interface. Like the math class, the memory<BR>
class consists solely of static member functions. Memory::copy writes a specified<BR>
number of bytes from one memory location to another. Memory::compare<BR>
determines if a specified number of bytes at one memory location is identical to<BR>
those at another location. If so, Memory::compare returns 0. Otherwise, it returns<BR>
a non-zero value. Memory::zero sets a specified number of bytes to zero starting<BR>
at a given memory location.<BR>
&nbsp;&nbsp;In certain circumstances, memory operations are faster than a loop over a set<BR>
of elements. Memory::zero and Memory::copy are useful for implementing a<BR>
dynamic array, quickly clearing or copying data when the array grows.<BR><BR>
&nbsp;&nbsp;A- 
<BR>
<A NAME="PAGE74"></A>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>A.6 String<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Figure A.6 shows the string class interface. The purpose of the string class is to<BR>
provide a convenient set of operations for manipulating variable-length character<BR>
arrays, <!-- /Times-Italic -->
<I>not </I><!-- /Times-Roman -->
to manage storage. The base class does not allocate or free any storage<BR>
associated with the characters.<BR>
&nbsp;&nbsp;Three string constructors are available. The first, with no arguments, creates an<BR>
uninitialized string that should be assigned to another string before use. The<BR>
second, with a character pointer, sets the string's data to the given pointer. The<BR>
string's length is computed from the pointer under the assumption that the data<BR>
is null-terminated. The third constructor takes a character pointer and explicit<BR>
length. It does not assume the data is null-terminated.<BR>
&nbsp;&nbsp;String::string returns a pointer to the character data, which may not be<BR>
null-terminated. String::length returns the number of characters in the string.<BR>
String::null_terminated returns whether the string is already known to be<BR>
null-terminated (it does not attempt to find a null). String::hash returns a value for<BR>
the string data suitable for indexing the strings into a hash table.<BR>
&nbsp;&nbsp;The string class provides operators for assignment and comparison. The second<BR>
operand for these operations can be a string or a character pointer. In the latter<BR>
case, the data is assumed to be null-terminated. String::case_insensitive_equal<BR>
tests for equality ignoring the case of the characters in the strings.<BR><BR><BR><BR><BR>
&nbsp;&nbsp;A- 5
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
interface Math {<BR>
&nbsp;&nbsp;static float min(float a, float b);<BR>
&nbsp;&nbsp;static float max(float a, float b);<BR>
&nbsp;&nbsp;static float min(float a, float b, float c, float d);<BR>
&nbsp;&nbsp;static float max(float a, float b, float c, float d);<BR>
&nbsp;&nbsp;static int abs(int);<BR>
&nbsp;&nbsp;static long abs(long);<BR>
&nbsp;&nbsp;static double abs(double);<BR>
&nbsp;&nbsp;static int round(float);<BR>
&nbsp;&nbsp;static int round(double);<BR>
&nbsp;&nbsp;static boolean equal(float x, float y, float e);<BR>
&nbsp;&nbsp;static boolean equal(double x, double y, double e);<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure A.4: Math class interface.
&nbsp;&nbsp; 
&nbsp;&nbsp;<BR><BR><BR><BR><BR>
&nbsp;&nbsp;interface Memory {<BR>
&nbsp;&nbsp;static void copy(const void*, void* to, unsigned int nbytes);<BR>
&nbsp;&nbsp;static int compare(const void*, const void*, unsigned int nbytes);<BR>
&nbsp;&nbsp;static void zero(void*, unsigned int nbytes);<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure A.5: Memory class interface.
<BR>
<A NAME="PAGE75"></A>
&nbsp;&nbsp;</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
The subscript operator allows access to individual characters. It is an error to<BR>
pass a negative index or an index greater than or equal to the length of the string.<BR>
String::substr returns a new string representing the part of the original string<BR>
begining at the <!-- /Times-Italic -->
<I>start </I><!-- /Times-Roman -->
parameter and continuing for <!-- /Times-Italic -->
<I>length </I><!-- /Times-Roman -->
characters. If <!-- /Times-Italic -->
<I>start </I><!-- /Times-Roman -->
is<BR>
negative, the beginning position is the end of the string offset by <!-- /Times-Italic -->
<I>start. </I><!-- /Times-Roman -->
If <!-- /Times-Italic -->
<I>length </I><!-- /Times-Roman -->
is<BR>
±1, then the remainder of the string is included. String::substr does not copy the<BR>
data, it simply creates another string that points into the same data as the original<BR>
string. String::left and String::right are short-hand for accessing the beginning or<BR>
end of a string. String::set_to_substr, String::set_to_left, and String::set_to_right<BR>
are convenience for changing a string to a particular substring instead of creating<BR>
a new string.<BR>
&nbsp;&nbsp;String::search returns the index of the occurrence of the given character after<BR><BR><BR><BR><BR>
&nbsp;&nbsp;A- 6
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
interface String {<BR>
&nbsp;&nbsp;String();<BR>
&nbsp;&nbsp;String(const char*);<BR>
&nbsp;&nbsp;String(const char*, int length);<BR>
&nbsp;&nbsp;const char* string() const;<BR>
&nbsp;&nbsp;int length() const;<BR>
&nbsp;&nbsp;boolean null_terminated() const;<BR>
&nbsp;&nbsp;unsigned long hash() const;<BR>
&nbsp;&nbsp;String& operator =(const String&);<BR>
&nbsp;&nbsp;boolean operator ==(const String&) const;<BR>
&nbsp;&nbsp;boolean operator !=(const String&) const;<BR>
&nbsp;&nbsp;boolean operator >(const String&) const;<BR>
&nbsp;&nbsp;boolean operator >=(const String&) const;<BR>
&nbsp;&nbsp;boolean operator <(const String&) const;<BR>
&nbsp;&nbsp;boolean operator <=(const String&) const;<BR>
&nbsp;&nbsp;boolean case_insensitive_equal(const String&) const;<BR>
&nbsp;&nbsp;char operator[](int index) const;<BR>
&nbsp;&nbsp;String substr(int start, int length) const;<BR>
&nbsp;&nbsp;String left(int length) const;<BR>
&nbsp;&nbsp;String right(int start) const;<BR>
&nbsp;&nbsp;void set_to_substr(int start, int length);<BR>
&nbsp;&nbsp;void set_to_left(int length);<BR>
&nbsp;&nbsp;void set_to_right(int start);<BR>
&nbsp;&nbsp;int search(int start, char) const;<BR>
&nbsp;&nbsp;int index(char) const;<BR>
&nbsp;&nbsp;int rindex(char) const;<BR>
&nbsp;&nbsp;boolean convert(int&) const;<BR>
&nbsp;&nbsp;boolean convert(long&) const;<BR>
&nbsp;&nbsp;boolean convert(float&) const;<BR>
&nbsp;&nbsp;boolean convert(double&) const;<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure A.6: String class interface.
<BR>
<A NAME="PAGE76"></A>
</FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
the given starting position. If the starting position is negative, it is treated as an<BR>
offset from the end of the string and the search is made right-to-left. String::index<BR>
and String::rindex are short-hand for searching from the beginning and end of the<BR>
string, respectively.<BR>
&nbsp;&nbsp;String::convert attempts to interpret the string as a number and sets its<BR>
parameter to the value. If the conversion is successful, String::convert returns true.<BR>
&nbsp;&nbsp;Three string subclasses of string are provided, all of which have the same<BR>
constructors and operations as the base class. CopyString is a subclass that<BR>
copies the string data when constructed and frees the storage when deleted.<BR>
When the copy is made, a null is appended to ensure the data is null-terminated.<BR>
NullTerminatedString is a subclass that guarantees its data is null-terminated. If<BR>
constructed with a normal string, it will copy the data much like a copy-string.<BR>
However, if the given string is already a copy-string, then no copy is made.<BR>
NullTerminatedString is useful for passing string data to external C functions,<BR>
such as printf.<BR>
&nbsp;&nbsp;The third string subclass is UniqueString, which uses a table to map identical<BR>
strings to the same data. Comparing unique strings for equality is fast because the<BR>
implementation can compare pointers instead of the string data. Unique strings<BR>
are not null-terminated.<BR><BR>
</FONT>
<FONT SIZE=6>
<!-- /Times-Bold -->
<B>A.7 Table<BR><BR>
</B></FONT>
<FONT SIZE=3>
<!-- /Times-Roman -->
Figure A.7 shows the table class interface. Table is a generic class that is<BR>
parameterized by a key type and a value type. The constructor is given a size for<BR>
the hash table implementation. For good access performance, the size should be<BR>
roughly twice the expected number of keys.<BR>
&nbsp;&nbsp;Table::insert stores a <key,value> pair. Table::find searches an entry with<BR>
the given key. If such an entry exists, Table::find sets <!-- /Times-Italic -->
<I>value </I><!-- /Times-Roman -->
and returns true.<BR>
Otherwise, it leaves the parameter unmodified and returns false. Table::remove<BR>
deletes a <key,value> pair from the table if one exists. Table::find_and_remove<BR>
combines the find and remove operations in a single call.<BR>
&nbsp;&nbsp;If the same key is inserted more than once, Table::find will return the most<BR>
recently inserted value. Similarly, Table::remove will delete the most recently<BR>
inserted pair.<BR>
&nbsp;&nbsp;TableIterator allows one to iterate over all the <key,value> pairs defined in a<BR>
table. TableIterator is parameterized explicitly by the table type, implicitly by the<BR>
key and value types. TableIterator::cur_key and TableIterator::cur_value return<BR>
the current entry information. TableIterator::more tests if additional entries are<BR>
defined. TableIterator::next moves to the next entry in the table.<BR><BR><BR><BR><BR>
&nbsp;&nbsp;A- 
<BR>
<A NAME="PAGE77"></A>
&nbsp;&nbsp;A- 8
&nbsp;&nbsp;<BR>
&nbsp;&nbsp;</FONT>
<FONT SIZE=2>
<!-- /Helvetica -->
unsigned long key_to_hash(Key);<BR>
&nbsp;&nbsp;interface Table(Key,Value) {<BR>
&nbsp;&nbsp;Table(Key,Value)(int hash_table_size);<BR>
&nbsp;&nbsp;void insert(Key, Value);<BR>
&nbsp;&nbsp;boolean find(Value&, Key);<BR>
&nbsp;&nbsp;void remove(Key);<BR>
&nbsp;&nbsp;boolean find_and_remove(Value&, Key);<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;interface TableIterator(Table(Key,Value)) {<BR>
&nbsp;&nbsp;TableIterator(Table(Key,Value))(Table(Key,Value)&);<BR>
&nbsp;&nbsp;Key& cur_key();<BR>
&nbsp;&nbsp;Value& cur_value();<BR>
&nbsp;&nbsp;boolean more();<BR>
&nbsp;&nbsp;boolean next();<BR>
&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;Figure A.7: Table class interface.
<BR>
<A NAME="PAGE78"></A>
</BODY>
