<HTML>
<BODY>
<PRE>
<!-- Manpage converted by man2html 3.0.1 -->
       ConnectManip,  DragManip, ManipGroup, TextManip, VertexMa-
       nip - Manipulator subclasses for defining  common  direct-
       manipulation semantics


</PRE>
<H2>SYNOPSIS</H2><PRE>
       <B>#include</B> <B>&lt;Unidraw/manips.h&gt;</B>


</PRE>
<H2>DESCRIPTION</H2><PRE>
       Manipulator  is  an  abstract  base class for objects that
       encapsulate the mechanics of  direct  manipulation.   Sub-
       classes  support  different  manipulation  semantics.  The
       DragManip  subclass  implements  a  downclick-drag-upclick
       style  of interaction, with optional constraints on motion
       (for example, horizontal or vertical only).   ConnectManip
       is  a  DragManip  subclass  that adds a gravitational bias
       towards connector views.  VertexManip is a DragManip  that
       supports  multiple  downclick-and-drag interactions termi-
       nated by a distinguished downclick.  TextManip provides  a
       text  editing  interface.   Finally,  ManipGroup  composes
       manipulator instances so that their interaction  may  pro-
       ceed concurrently.


</PRE>
<H2>DRAGMANIP PUBLIC OPERATIONS</H2><PRE>
       <B>DragManip(</B>
           <B>Viewer*,</B> <B>Rubberband*,</B> <B>Transformer*</B> <B>=</B> <B>nil,</B> <B>Tool*</B> <B>=</B> <B>nil,</B>
           <B>DragConstraint</B> <B>=</B> <B>None</B>
       <B>)</B>

       <B>DragManip(</B>
           <B>Viewer*,</B> <B>Rubberband*,</B> <B>Transformer*,</B> <B>Tool*,</B>
           <B>DragConstraint,</B> <B>Coord,</B> <B>Coord</B>
       <B>)</B>
              A DragManip uses a rubberband to animate the manip-
              ulation.  The constructor takes the rubberband as a
              parameter along with the viewer in which it  should
              appear, a transformer reflecting the transformation
              that component views undergo  in  the  viewer,  the
              tool  that  created the manipulator, and a DragCon-
              straint that effectively restricts mouse motion  in
              one  or  more  ways.   By  default,  motion is con-
              strained when the Shift key is held down.  The sec-
              ond  constructor  adds  two  Coord parameters.  The
              DragManip will use these  values  to  override  the
              event coordinates when Grasp is first called.

       <B>virtual</B> <B>void</B> <B>Grasp(Event&amp;)</B>
              DragManip  redefines  Grasp  operation  to call the
              rubberband's Track operation, supplying the coordi-
              nates   in   the   event.   Grasp  calls  Constrain
              (described below) on the event prior to passing the
              coordinate information.  The rubberband will not be
              drawn until Grasp is called.
              If the event is a MotionEvent,  Manipulating  calls
              Track  with  the  event's  coordinates  and returns
              <I>true</I>.  Manipulating simply  returns  <I>false</I>  if  the
              event  is  an UpEvent.  Like DragManip::Grasp, this
              operation calls Constrain on  the  event  prior  to
              passing the coordinate information.

       <B>virtual</B> <B>void</B> <B>Effect(Event&amp;)</B>
              Effect  simply erases the rubberband by calling its
              Erase operation.

       <B>virtual</B> <B>void</B> <B>SetViewer(Viewer*)</B>
       <B>virtual</B> <B>void</B> <B>SetRubberband(Rubberband*)</B>
       <B>virtual</B> <B>void</B> <B>SetTransformer(Transformer*)</B>
       <B>virtual</B> <B>void</B> <B>SetTool(Tool*)</B>
       <B>virtual</B> <B>void</B> <B>SetConstraint(DragConstraint)</B>

       <B>virtual</B> <B>Viewer*</B> <B>GetViewer()</B>
       <B>virtual</B> <B>Rubberband*</B> <B>GetRubberband()</B>
       <B>virtual</B> <B>Transformer*</B> <B>GetTransformer()</B>
       <B>virtual</B> <B>Tool*</B> <B>GetTool()</B>
       <B>virtual</B> <B>DragConstraint</B> <B>GetConstraint()</B>
              Set and get the various parameters supplied to  the
              DragManip in its constructor.

       <B>const</B> <B>Event&amp;</B> <B>GraspEvent()</B>
              Return  the  event  supplied  to  the  last call to
              Grasp.


</PRE>
<H2>DRAGMANIP PROTECTED OPERATIONS</H2><PRE>
       <B>void</B> <B>Init(</B>
           <B>Viewer*,</B> <B>Rubberband*,</B> <B>Transformer*,</B> <B>Tool*,</B> <B>DragCon-</B>
              <B>straint</B>
       <B>)</B>
              Assign  the  various  constructor  values common to
              both DragManip constructors.

       <B>virtual</B> <B>void</B> <B>Constrain(Event&amp;)</B>
              Constrain the event to reflect the  DragConstraint.
              The  event  coordinates  are  constrained  when the
              event indicates that the shift key is held down for
              all  DragConstraint  values  except  Gravity, which
              constrains the coordinates unconditionally with the
              viewer's Constrain operation.


</PRE>
<H2>CONNECTMANIP PUBLIC OPERATIONS</H2><PRE>
       <B>ConnectManip(</B>
           <B>Viewer*,</B> <B>Rubberband*,</B> <B>Transformer*</B> <B>=</B> <B>nil,</B> <B>Tool*</B> <B>=</B> <B>nil</B>
       <B>)</B>
              ConnectManip  supports the same type of interaction
              as DragManip, except  the  rubberband  tracking  is
              affected  by  a graviational bias towards connector
              strained to coincide with the center of the connec-
              tor  view.   The  rubberband  will  not  change its
              appearance thereafter until the user  drags  beyond
              the  gravity  threshold,  which corresponds to SLOP
              (see <B>globals(3U)</B>) units beyond the nearest point on
              the connector view.

       <B>virtual</B> <B>boolean</B> <B>Manipulating(Event&amp;)</B>
              ConnectManip  redefines Manipulating to support the
              gravitational effect.

       <B>ConnectorView*</B> <B>GetTarget()</B>
              Return the connector view  that  has  captured  the
              rubberband, if any.


</PRE>
<H2>VERTEXMANIP PUBLIC OPERATIONS</H2><PRE>
       <B>VertexManip(</B>
           <B>Viewer*,</B> <B>GrowingVertices*,</B> <B>Transformer*</B> <B>=</B> <B>nil,</B>
           <B>Tool*</B> <B>=</B> <B>nil,</B> <B>DragConstraint</B> <B>=</B> <B>None</B>
       <B>)</B>
              VertexManip is like DragManip but supports multiple
              drags and clicks in one manipulation.  The  Vertex-
              Manip constructor restricts the rubberband to be an
              instance of GrowingVertices.

       <B>virtual</B> <B>boolean</B> <B>Manipulating(Event&amp;)</B>
              This operation is similar to DragManip's, except it
              calls  AppendVertex  on the GrowingVertices rubber-
              band on each down-click and returns  <I>false</I>  if  and
              only if the middle button is pressed.

       <B>GrowingVertices*</B> <B>GetGrowingVertices()</B>
              Return  the  GrowingVertices  instance.   Use  this
              operation as an alternative to  GetRubberband  when
              that operation isn't specific enough.


</PRE>
<H2>TEXTMANIP PUBLIC OPERATIONS</H2><PRE>
       <B>TextManip(Viewer*,</B> <B>Painter*,</B> <B>Coord</B> <B>tabwidth,</B> <B>Tool*</B> <B>=</B> <B>nil)</B>
       <B>TextManip(</B>
           <B>Viewer*,</B> <B>Painter*,</B> <B>Coord</B> <B>lineheight,</B> <B>Coord</B> <B>tabwidth,</B>
           <B>Tool*</B> <B>=</B> <B>nil</B>
       <B>)</B>
              Create   a  TextManip,  supplying  (at  minimum)  a
              viewer, a  painter  with  which  to  draw  (usually
              reflecting   graphics  attributes  defined  by  the
              enclosing editor object), and the width  of  a  tab
              character.   Tab  characters in the text will posi-
              tion the following character at an integral  multi-
              ple  of  <I>tabwidth</I>  from  the beginning of the line.
              The distance between baselines in the text  can  be
              specified  with  the second constructor; this value
              corresponds to the font height by  default.   These
              line  of  text  (including  the  descender) will be
              positioned at the coordinates in the  event  passed
              to the Grasp operation.

       <B>TextManip(</B>
           <B>Viewer*,</B> <B>const</B> <B>char*</B> <B>buf,</B> <B>int</B> <B>bufsize,</B> <B>Coord</B> <B>x,</B> <B>Coord</B>
              <B>y,</B>
           <B>Painter*,</B> <B>Coord</B> <B>tabwidth,</B> <B>Tool*</B> <B>=</B> <B>nil</B>
       <B>)</B>

       <B>TextManip(</B>
           <B>Viewer*,</B> <B>const</B> <B>char*</B> <B>buf,</B> <B>int</B> <B>bufsize,</B> <B>Coord</B> <B>x,</B> <B>Coord</B>
              <B>y,</B>
           <B>Painter*,</B> <B>Coord</B> <B>lineheight,</B> <B>Coord</B> <B>tabwidth,</B> <B>Tool*</B> <B>=</B>
              <B>nil</B>
       <B>)</B>
              Create text manipulators initialized with  text  by
              passing  a  buffer of text and its size.  A copy of
              the buffer is used internally.  The <I>x</I> and <I>y</I> parame-
              ters  specify the position of the lower left corner
              of the first line of text  (including  the  descen-
              der).   These coordinates will override the coordi-
              nates specified by the event passed to Grasp.

       <B>virtual</B> <B>void</B> <B>Grasp(Event&amp;)</B>
              Positions and draws the  text.   If  the  position-
              specifing  constructors  were  used  to  create the
              instance, then the manipulator will use  the  event
              coordinates  to  set the insertion point's position
              in the text.

       <B>virtual</B> <B>boolean</B> <B>Manipulating(Event&amp;)</B>
              Handle keystrokes and/or  mouse  motion  events  to
              support  basic  text  editing.   Motion  events are
              interpreted to  support  text  selection;  selected
              text  is  displayed in reverse colors.  The Manipu-
              lating operation returns <I>false</I> if  a  downclick  is
              detected   outside   the   text   or  if  HandleKey
              (described below) returns <I>false</I>.

       <B>virtual</B> <B>void</B> <B>Effect(Event&amp;)</B>
              Effect damages the viewer area that TextManip  cor-
              rupted during editing.

       <B>virtual</B> <B>Painter*</B> <B>GetPainter()</B>
       <B>virtual</B> <B>Coord</B> <B>GetLineHeight()</B>
       <B>virtual</B> <B>Coord</B> <B>GetTabWidth()</B>
       <B>virtual</B> <B>const</B> <B>char*</B> <B>GetText(int&amp;)</B>
       <B>virtual</B> <B>void</B> <B>GetPosition(Coord&amp;,</B> <B>Coord&amp;)</B>
              Return  various  parameters  specified  in the con-
              structor.  GetText returns a pointer to the  inter-
              nal  buffer  containing  the  text;  the  reference
              Return the event  supplied  to  the  last  call  to
              Grasp.


</PRE>
<H2>TEXTMANIP PROTECTED OPERATIONS</H2><PRE>
       <B>virtual</B> <B>boolean</B> <B>HandleKey(Event&amp;)</B>
              This  operation  defines  TextManip's  default  key
              bindings  as  described  below.   Unless  otherwise
              noted below, this function returns <I>true</I>.

              <B>(^P)</B> backward line

              <B>(^N)</B> forward line

              <B>(^B)</B> backward character

              <B>(^F)</B> forward character

              <B>(ESC)</B>  terminate  text  entry, causing HandleKey to
              return <I>false</I>

              <B>(^A)</B> beginning of line

              <B>(^E)</B> end of line

              <B>(^D)</B> delete character

              <B>(DEL)</B> <B>(^H)</B> delete backward character

       <B>int</B> <B>Dot()</B>
       <B>int</B> <B>Mark()</B>
              The current selection is  bounded  by  two  indices
              into  the text buffer.  By convention these indices
              are called dot and mark.  Dot is  the  position  at
              which  text  will  be  inserted  and deleted.  Mark
              locates the end of the selection that moves as  the
              selection is modified.  When the selection is empty
              (an insertion point), dot and mark are equal.

       <B>void</B> <B>InsertText(const</B> <B>char*</B> <B>string,</B> <B>int</B> <B>count)</B>
       <B>void</B> <B>InsertCharacter(char)</B>
       <B>void</B> <B>DeleteText(int</B> <B>count)</B>
       <B>void</B> <B>DeleteCharacter(int)</B>
       <B>void</B> <B>DeleteLine()</B>
       <B>void</B> <B>DeleteSelection()</B>
              Edit the text  buffer  at  the  current  selection.
              InsertText  inserts  count  characters  from string
              after dot.   The  selection  becomes  an  insertion
              point    following   the   newly   inserted   text.
              InsertCharacter replaces  the  selected  characters
              with  a  single character. DeleteText deletes count
              characters at dot.  If count is positive, the char-
              acters following dot are deleted; if count is nega-
              of the deleted text.  DeleteSelection  deletes  the
              text  between  dot and mark, changing the selection
              to an insertion point.  DeleteCharacter is  identi-
              cal  to  DeleteText if the dot and mark are not the
              same; otherwise it is identical to DeleteSelection.
              DeleteCharacter   provides   a  convenient  way  to
              express the behavior of the  backspace  and  delete
              operations.   Finally,  DeleteLine deletes the line
              of text containing mark.  The selection becomes  an
              insertion point at mark.

       <B>void</B> <B>BackwardCharacter(int</B> <B>count)</B>
       <B>void</B> <B>ForwardCharacter(int</B> <B>count)</B>
       <B>void</B> <B>BackwardLine(int</B> <B>count)</B>
       <B>void</B> <B>ForwardLine(int</B> <B>count)</B>
       <B>void</B> <B>BackwardWord(int</B> <B>count)</B>
       <B>void</B> <B>ForwardWord(int</B> <B>count)</B>
              Move  the  current selection forward or backward by
              the specified number of the specified  units.   The
              default movement is one unit.  The selection is not
              moved before the beginning of after the end of  the
              text.

       <B>void</B> <B>BeginningOfLine()</B>
       <B>void</B> <B>EndOfLine()</B>
       <B>void</B> <B>BeginningOfWord()</B>
       <B>void</B> <B>EndOfWord()</B>
       <B>void</B> <B>BeginningOfSelection()</B>
       <B>void</B> <B>EndOfSelection()</B>
       <B>void</B> <B>BeginningOfText()</B>
       <B>void</B> <B>EndOfText()</B>
              Move the current selection forwards or backwards to
              the specified feature of the text.

       <B>void</B> <B>Select(int</B> <B>dot)</B>
       <B>void</B> <B>Select(int</B> <B>dot,</B> <B>int</B> <B>mark)</B>
       <B>void</B> <B>SelectMore(int</B> <B>mark)</B>
       <B>void</B> <B>SelectAll()</B>
              Modify the  current  selection  in  terms  of  text
              indices.   With  a  single  parameter, Select moves
              both dot and mark to the specified index.  With two
              parameters, dot and mark can be controlled indepen-
              dently.  SelectMore leaves dot unchanged and  moves
              mark.   SelectAll  sets  dot to the end of the text
              and mark to the beginning.

       <B>int</B> <B>Locate(Coord</B> <B>x,</B> <B>Coord</B> <B>y)</B>
       <B>boolean</B> <B>Contains(Coord,</B> <B>Coord)</B>
              Locate returns the text index most closely matching
              the  point  (<I>x</I>,  <I>y</I>).   Contains returns whether the
              text contains the point (<I>x</I>, <I>y</I>).

       <B>ManipGroup(Viewer*</B> <B>=</B> <B>nil,</B> <B>Tool*</B> <B>=</B> <B>nil)</B>
              Create a ManipGroup, optionally supplying a  viewer
              and a tool.

       <B>virtual</B> <B>void</B> <B>Grasp(Event&amp;)</B>
              The  Grasp  operation  simply  calls  Grasp on each
              child in insertion order.

       <B>virtual</B> <B>boolean</B> <B>Manipulating(Event&amp;)</B>
              Manipulating calls the corresponding  operation  on
              each  child,  skipping  those  children  that  have
              returned <I>false</I> in previous calls (up  to  the  last
              Grasp).  This function returns <I>false</I> when all chil-
              dren have done so.

       <B>virtual</B> <B>void</B> <B>Effect(Event&amp;)</B>
              ManipGroup's Effect operation calls Effect on  each
              child.

       <B>virtual</B> <B>void</B> <B>SetViewer(Viewer*)</B>
       <B>virtual</B> <B>void</B> <B>SetTool(Tool*)</B>
       <B>virtual</B> <B>Viewer*</B> <B>GetViewer()</B>
       <B>virtual</B> <B>Tool*</B> <B>GetTool()</B>
              Set  and get the ManipGroup's viewer and tool.  The
              set operations  set  the  ManipGroup's  values  for
              these  parameters and call the corresponding opera-
              tions on their children.  The get operations simply
              return the ManipGroup's values.

       <B>virtual</B> <B>void</B> <B>First(Iterator&amp;)</B>
       <B>virtual</B> <B>void</B> <B>Last(Iterator&amp;)</B>
       <B>virtual</B> <B>void</B> <B>Next(Iterator&amp;)</B>
       <B>virtual</B> <B>void</B> <B>Prev(Iterator&amp;)</B>
       <B>virtual</B> <B>boolean</B> <B>Done(Iterator)</B>
              Operations  for  iterating  over  the  ManipGroup's
              children, if any.  First  and  Last  initialize  an
              iterator  to  point to the beginning and end of the
              list of children,  respectively.   Next  increments
              the iterator to point to the following child, while
              Prev decrements the iterator to point to  the  pre-
              ceding  child.   Done  returns  whether  or not the
              iterator points beyond the first or last  child  in
              the list.

       <B>Manipulator*</B> <B>GetManip(Iterator)</B>
       <B>void</B> <B>SetManip(Manipulator*,</B> <B>Iterator&amp;)</B>
              GetManip  returns the child manipulator to which an
              iterator points.  SetManip initializes an  iterator
              to  point to a particular child; it initializes the
              iterator to point to a nil instance  if  the  given
              Manipulator is not a child of the ManipGroup.

           <B>Manipulator*,</B>
           <B>Manipulator*</B> <B>=</B> <B>nil,</B> <B>Manipulator*</B> <B>=</B> <B>nil,</B> <B>Manipulator*</B> <B>=</B>
              <B>nil</B>
       <B>)</B>

       <B>void</B> <B>Prepend(</B>
           <B>Manipulator*,</B>
           <B>Manipulator*</B> <B>=</B> <B>nil,</B> <B>Manipulator*</B> <B>=</B> <B>nil,</B> <B>Manipulator*</B> <B>=</B>
              <B>nil</B>
       <B>)</B>

       <B>void</B> <B>InsertBefore(Iterator,</B> <B>Manipulator*)</B>
       <B>void</B> <B>InsertAfter(Iterator,</B> <B>Manipulator*)</B>
       <B>void</B> <B>Remove(Manipulator*)</B>
       <B>void</B> <B>Remove(Iterator&amp;)</B>
              Operations  for  modifying the ManipGroup's list of
              children.  Append and Prepend add up to four  child
              manipulators,  in  order, to the end and the begin-
              ning of the list,  respectively.   InsertAfter  and
              InsertBefore  insert  a  child after and before the
              manipulator pointed to  by  the  iterator,  respec-
              tively.   The Remove operations remove a child from
              the list (without deleting it).  You can  remove  a
              child  by referring to it explicitly or by specify-
              ing an iterator.  If an iterator is  supplied,  the
              Remove  operation  will  advance it to point to the
              following child as a side effect.


</PRE>
<H2>MANIPGROUP PROTECTED OPERATIONS</H2><PRE>
       <B>UList*</B> <B>Elem(Iterator)</B>
       <B>Manipulator*</B> <B>Manip(UList*)</B>
              ManipGroup stores its children on a UList, which is
              accessible  via  the  <B>_</B><I>kids</I>  protected member.  The
              Selection's iteration operations  store  the  UList
              containing  the  current  child  in their iterator.
              Elem is a convenience function  for  returning  the
              UList  to  which  an  iterator  points,  and  Manip
              extracts the child that a UList element contains.


</PRE>
<H2>SEE ALSO</H2><PRE>
       <B>Connector(3U)</B>, <B>Event(3I)</B>,  <B>Iterator(3U)</B>,  <B>Manipulator(3U)</B>,
       <B>Painter(3I)</B>,   <B>Rubband(3I)</B>,   <B>Tool(3U)</B>,   <B>Transformer(3I)</B>,
       <B>UList(3U)</B>, <B>Viewer(3U)</B>, <B>globals(3U)</B>









</PRE>
<HR>
<ADDRESS>
Man(1) output converted with
<a href="http://www.oac.uci.edu/indiv/ehood/man2html.html">man2html</a>
</ADDRESS>
</BODY>
</HTML>
